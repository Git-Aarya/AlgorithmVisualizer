// js/main.js

document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const algoNav = document.getElementById('algo-nav');
    const currentAlgoTitle = document.getElementById('current-algo-title');
    const visualizationArea = document.getElementById('visualization-area');
    const extraVisualizationArea = document.getElementById('extra-visualization-area');
    const codeBlock = document.getElementById('code-block');
    const pseudoBlock = document.getElementById('pseudo-block');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const stepForwardBtn = document.getElementById('step-forward-btn');
    const stepBackBtn = document.getElementById('step-back-btn');
    const resetBtn = document.getElementById('reset-btn');
    const generateDataBtn = document.getElementById('generate-data-btn');
    const speedSlider = document.getElementById('speed-slider');
    const codeContent = document.getElementById('code-content');
    const pseudoContent = document.getElementById('pseudo-content');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const statusMessage = document.getElementById('status-message');
    const tabButtons = document.querySelectorAll('.tab-btn');

    // --- State Variables ---
    let currentAlgorithmKey = null;
    let currentAlgorithm = null; // Will reference an object from algorithms collection
    let currentData = [];
    let animationState = {
        steps: [],           // Array of step objects generated by algorithm setup
        elements: [],        // Array of DOM elements for main visualization (e.g., bars)
        countElements: [],   // Array of DOM elements for count array (if used)
        outputElements: [],  // Array of DOM elements for output array (if used)
        currentStep: -1,     // Index of the current step being displayed
        isPlaying: false,    // Is the animation currently playing?
        timerId: null,       // ID for setTimeout used in play mode
        speed: 500,          // Current animation delay (initialized later)
        targetValue: null,   // Target value for search algorithms
    };

    // --- Collect Algorithm Definitions ---
    // Assumes individual algorithm files have loaded and defined global config variables
    const algorithms = {
        // Implemented Algorithms (Loaded from individual files)
        'linear-search': typeof linearSearchConfig !== 'undefined' ? linearSearchConfig : null,
        'binary-search': typeof binarySearchConfig !== 'undefined' ? binarySearchConfig : null,
        'bubble-sort': typeof bubbleSortConfig !== 'undefined' ? bubbleSortConfig : null,
        'selection-sort': typeof selectionSortConfig !== 'undefined' ? selectionSortConfig : null,
        'insertion-sort': typeof insertionSortConfig !== 'undefined' ? insertionSortConfig : null,
        'merge-sort': typeof mergeSortConfig !== 'undefined' ? mergeSortConfig : null,
        'quick-sort': typeof quickSortConfig !== 'undefined' ? quickSortConfig : null,
        'heap-sort': typeof heapSortConfig !== 'undefined' ? heapSortConfig : null,
        'counting-sort': typeof countingSortConfig !== 'undefined' ? countingSortConfig : null,
        'tree-traversals': typeof treeTraversalsConfig !== 'undefined' ? treeTraversalsConfig : null,
        'bst': typeof bstConfig !== 'undefined' ? bstConfig : null,
        'avl': typeof avlConfig !== 'undefined' ? avlConfig : null,
        // Add entries for any other *implemented* algorithms you create files for

        // --- Placeholder definitions for algorithms NOT yet implemented ---
        // (Keep these directly defined here until you implement them)
        'heap-ops': { name: 'Heap Operations (Insert/Extract)', code: '// TODO: Heap Operations Code', pseudocode: '// TODO: Heap Operations Pseudocode', setup: null, renderStep: null },
        'tree-bfs-dfs': { name: 'BFS & DFS (Trees)', code: '// TODO: Tree BFS/DFS Code', pseudocode: '// TODO: Tree BFS/DFS Pseudocode', setup: null, renderStep: null },
        'graph-bfs': { name: 'BFS (Graphs)', code: '// TODO: Graph BFS Code', pseudocode: '// TODO: Graph BFS Pseudocode', setup: null, renderStep: null },
        'graph-dfs': { name: 'DFS (Graphs)', code: '// TODO: Graph DFS Code', pseudocode: '// TODO: Graph DFS Pseudocode', setup: null, renderStep: null },
        'dijkstra': { name: 'Dijkstra’s Algorithm', code: '// TODO: Dijkstra Code', pseudocode: '// TODO: Dijkstra Pseudocode', setup: null, renderStep: null },
        'bellman-ford': { name: 'Bellman-Ford', code: '// TODO: Bellman-Ford Code', pseudocode: '// TODO: Bellman-Ford Pseudocode', setup: null, renderStep: null },
        'floyd-warshall': { name: 'Floyd-Warshall', code: '// TODO: Floyd-Warshall Code', pseudocode: '// TODO: Floyd-Warshall Pseudocode', setup: null, renderStep: null },
        'kruskal': { name: 'Kruskal’s MST', code: '// TODO: Kruskal Code', pseudocode: '// TODO: Kruskal Pseudocode', setup: null, renderStep: null },
        'prim': { name: 'Prim’s MST', code: '// TODO: Prim Code', pseudocode: '// TODO: Prim Pseudocode', setup: null, renderStep: null },
        'topo-sort': { name: 'Topological Sorting', code: '// TODO: Topological Sort Code', pseudocode: '// TODO: Topological Sort Pseudocode', setup: null, renderStep: null },
        'fibonacci': { name: 'Fibonacci (DP/Memo)', code: '// TODO: Fibonacci Code', pseudocode: '// TODO: Fibonacci Pseudocode', setup: null, renderStep: null },
        'lcs': { name: 'Longest Common Subsequence', code: '// TODO: LCS Code', pseudocode: '// TODO: LCS Pseudocode', setup: null, renderStep: null },
        'knapsack': { name: '0/1 Knapsack', code: '// TODO: Knapsack Code', pseudocode: '// TODO: Knapsack Pseudocode', setup: null, renderStep: null },
        'coin-change': { name: 'Coin Change', code: '// TODO: Coin Change Code', pseudocode: '// TODO: Coin Change Pseudocode', setup: null, renderStep: null },
        'mcm': { name: 'Matrix Chain Multiplication', code: '// TODO: MCM Code', pseudocode: '// TODO: MCM Pseudocode', setup: null, renderStep: null },
        'n-queens': { name: 'N-Queens', code: '// TODO: N-Queens Code', pseudocode: '// TODO: N-Queens Pseudocode', setup: null, renderStep: null },
        'sudoku': { name: 'Sudoku Solver', code: '// TODO: Sudoku Solver Code', pseudocode: '// TODO: Sudoku Solver Pseudocode', setup: null, renderStep: null },
        'rat-maze': { name: 'Rat in a Maze', code: '// TODO: Rat Maze Code', pseudocode: '// TODO: Rat Maze Pseudocode', setup: null, renderStep: null },
        'word-search': { name: 'Word Search', code: '// TODO: Word Search Code', pseudocode: '// TODO: Word Search Pseudocode', setup: null, renderStep: null },
        'union-find': { name: 'Union-Find', code: '// TODO: Union-Find Code', pseudocode: '// TODO: Union-Find Pseudocode', setup: null, renderStep: null },
        'kmp': { name: 'KMP Algorithm', code: '// TODO: KMP Code', pseudocode: '// TODO: KMP Pseudocode', setup: null, renderStep: null },
        'rabin-karp': { name: 'Rabin-Karp', code: '// TODO: Rabin-Karp Code', pseudocode: '// TODO: Rabin-Karp Pseudocode', setup: null, renderStep: null },
        'sliding-window': { name: 'Sliding Window', code: '// TODO: Sliding Window Code', pseudocode: '// TODO: Sliding Window Pseudocode', setup: null, renderStep: null },
        'two-pointers': { name: 'Two Pointers', code: '// TODO: Two Pointers Code', pseudocode: '// TODO: Two Pointers Pseudocode', setup: null, renderStep: null },
    };

    // Remove null entries (where a file failed to load/define variable)
    // and log a warning.
    Object.keys(algorithms).forEach(key => {
        if (algorithms[key] === null) {
            console.warn(`Algorithm config for '${key}' not found or loaded. Removing from list.`);
            delete algorithms[key];
        }
    });

    // --- Default/Placeholder Functions ---
    function defaultSetup(data) {
        const algoName = this && this.name ? this.name : 'Algorithm'; // 'this' is bound to the algorithm object
        const visArea = document.getElementById('visualization-area');
        const extraVisArea = document.getElementById('extra-visualization-area');
        if (visArea) visArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">${algoName} visualization not implemented yet.</p>`;
        if (extraVisArea) extraVisArea.innerHTML = '';
        if (statusMessage) statusMessage.textContent = 'Visualization not implemented.';
        return { steps: [], elements: [], countElements: [], outputElements: [], target: null };
    }

    function defaultRender(step, elements, animationState) {
        if (statusMessage) statusMessage.textContent = 'Rendering logic not implemented for this step.';
    }

    // --- Initialize Algorithms with Defaults ---
    // Iterate through the collected 'algorithms' object
    for (const key in algorithms) {
        if (algorithms.hasOwnProperty(key)) {
            // Assign default setup ONLY if setup is null or undefined
            if (!algorithms[key].setup) {
                algorithms[key].setup = defaultSetup.bind(algorithms[key]); // Bind 'this' context
            }
            // Assign default renderStep ONLY if renderStep is null or undefined
            if (!algorithms[key].renderStep) {
                algorithms[key].renderStep = defaultRender;
            }
        }
    }

    // --- Helper Functions ---
    function calculateDelay(sliderValue) {
        const minDelay = 50; // ms (fastest)
        const maxDelay = 1500; // ms (slowest)
        const value = Math.max(1, Math.min(10, sliderValue));
        return maxDelay - (value - 1) * (maxDelay - minDelay) / (10 - 1);
    }

    function generateSampleData(algoKey) {
        const size = 20;
        let minVal = 10;
        let maxVal = 100;
        let onlyPositiveInts = false;
        let requiresSorted = false;

        if (algorithms[algoKey]) {
            if (algorithms[algoKey].requiresPositiveInts) {
                onlyPositiveInts = true;
                minVal = 0;
                maxVal = 50;
            }
            if (algorithms[algoKey].requiresSortedData) {
                requiresSorted = true;
            }
        }

        let data = Array.from({ length: size }, () => {
            let val = Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal;
            return onlyPositiveInts ? Math.max(0, val) : val;
        });

        if (requiresSorted) {
            data.sort((a, b) => a - b);
        }
        console.log("Generated data:", data);
        return data;
    }

    // --- Core Application Logic ---
    function selectAlgorithm(algoKey) {
        console.log(`Attempting to select algorithm: ${algoKey}`);
        if (!algorithms[algoKey]) {
            console.error(`Algorithm "${algoKey}" not found in definitions.`);
            resetVisualizationState();
            currentAlgoTitle.textContent = 'Algorithm Not Found';
            codeBlock.innerHTML = '// Algorithm definition missing';
            pseudoBlock.textContent = '// Algorithm definition missing';
            visualizationArea.innerHTML = `<p class="text-red-500 dark:text-red-400 self-center">Error: Algorithm '${algoKey}' definition missing.</p>`;
            extraVisualizationArea.innerHTML = '';
            updateButtonStates();
            return;
        }

        pauseAnimation();
        currentAlgorithmKey = algoKey;
        currentAlgorithm = algorithms[algoKey];
        currentData = generateSampleData(currentAlgorithmKey);

        console.log(`Selected: ${currentAlgorithm.name}`);
        currentAlgoTitle.textContent = currentAlgorithm.name;
        codeBlock.innerHTML = currentAlgorithm.code || '// Code not available';
        pseudoBlock.textContent = currentAlgorithm.pseudocode || '// Pseudocode not available';

        setupVisualization();
    }

    function setupVisualization() {
        if (!currentAlgorithm || !currentData) {
            console.warn("Setup called without algorithm or data.");
            visualizationArea.innerHTML = '<p class="text-gray-500 dark:text-gray-400 self-center">Select an Algorithm</p>';
            extraVisualizationArea.innerHTML = '';
            statusMessage.textContent = 'Error: No algorithm selected for setup.';
            updateButtonStates();
            return;
        }

        console.log(`Setting up visualization for: ${currentAlgorithm.name}`);

        // --- HIDE/SHOW VISUALIZATION AREAS BASED ON TYPE ---
        const mainVisArea = document.getElementById('visualization-area');
        const extraVisArea = document.getElementById('extra-visualization-area');
        if (currentAlgorithm.type === 'tree') {
            if (mainVisArea) mainVisArea.style.display = 'none'; // Hide bar area
            if (extraVisArea) extraVisArea.style.display = 'block'; // Ensure extra area is visible
        } else {
            if (mainVisArea) mainVisArea.style.display = 'flex'; // Show bar area (using flex for centering)
            if (extraVisArea) extraVisArea.style.display = 'block'; // Keep extra area visible (for count sort etc.)
             // Ensure bar area has default content if no bars are added yet
             if(mainVisArea && mainVisArea.innerHTML === '') {
                 mainVisArea.innerHTML = '<p class="text-gray-500 dark:text-gray-400 self-center">Visualization appears here</p>';
             }
        }

        animationState = {
            ...animationState,
            steps: [],
            elements: [],
            countElements: [],
            outputElements: [],
            currentStep: -1,
            targetValue: null,
        };
        // Clear appropriate areas
        if (currentAlgorithm.type !== 'tree') { // Clear bar area only if not a tree
            if(mainVisArea) mainVisArea.innerHTML = '';
       }
       if (extraVisArea) extraVisArea.innerHTML = '';


       try {
        const setupResult = currentAlgorithm.setup(currentData);
         animationState.steps = setupResult.steps || [];
        animationState.elements = setupResult.elements || (currentAlgorithm.type === 'tree' ? {} : []);
        animationState.countElements = setupResult.countElements || [];
        animationState.outputElements = setupResult.outputElements || [];
        animationState.targetValue = setupResult.target;

        console.log(`Setup generated ${animationState.steps.length} steps.`);

        if (animationState.steps.length > 0) {
            animationState.currentStep = 0;
            currentAlgorithm.renderStep(animationState.steps[0], animationState.elements, animationState);
            statusMessage.textContent = animationState.steps[0]?.message || 'Ready';
        } else {
            // Handle cases where no steps are generated, respecting specific vis area
            const areaToShowMessage = currentAlgorithm.type === 'tree' ? extraVisArea : mainVisArea;
             if (areaToShowMessage && !areaToShowMessage.innerHTML.includes('visualization not implemented yet') && !areaToShowMessage.innerHTML.includes('requires non-negative integers')) {
                  areaToShowMessage.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">No visualization steps generated.</p>`;
             }
             statusMessage.textContent = 'No steps to visualize.';
        }
        } catch (error) {
            // ... (error handling remains the same)
             console.error(`Error during setup for ${currentAlgorithm.name}:`, error);
             const errorArea = currentAlgorithm.type === 'tree' ? extraVisArea : mainVisArea;
             if(errorArea) errorArea.innerHTML = `<p class="text-red-500 dark:text-red-400 self-center">Error during setup. Check console.</p>`;
             statusMessage.textContent = 'Error during setup';
             animationState.steps = [];
             animationState.elements = currentAlgorithm.type === 'tree' ? {} : [];
             animationState.countElements = [];
             animationState.outputElements = [];
             animationState.currentStep = -1;
        }

        updateButtonStates();
    }

    function resetVisualizationState() {
        console.log("Resetting visualization state.");
        pauseAnimation();
        currentAlgorithmKey = null;
        currentAlgorithm = null;
        currentData = [];
        animationState = {
            ...animationState,
            steps: [], elements: [], countElements: [], outputElements: [],
            currentStep: -1, isPlaying: false, timerId: null, targetValue: null,
        };
        visualizationArea.innerHTML = '<p class="text-gray-500 dark:text-gray-400 self-center">Select an Algorithm</p>';
        extraVisualizationArea.innerHTML = '';
        currentAlgoTitle.textContent = 'Select an Algorithm';
        codeBlock.innerHTML = '// Select an algorithm to view the code';
        pseudoBlock.textContent = '// Select an algorithm to view the pseudocode';
        statusMessage.textContent = '';
        updateButtonStates();
        document.querySelectorAll('#algo-nav a.active').forEach(a => a.classList.remove('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300', 'font-semibold', 'active'));
    }

    function switchTab(tabName) {
        console.log(`Switching tab to: ${tabName}`);
        tabButtons.forEach(button => {
            const isActive = button.dataset.tab === tabName;
            button.classList.toggle('active', isActive);
            button.classList.toggle('border-blue-500', isActive);
            button.classList.toggle('text-blue-600', isActive);
            button.classList.toggle('dark:text-blue-400', isActive);
            button.classList.toggle('border-transparent', !isActive);
            button.classList.toggle('text-gray-500', !isActive);
            button.classList.toggle('dark:text-gray-400', !isActive);
            button.classList.toggle('hover:text-gray-700', !isActive);
            button.classList.toggle('dark:hover:text-gray-300', !isActive);
            button.classList.toggle('hover:border-gray-300', !isActive);
            button.classList.toggle('dark:hover:border-gray-600', !isActive);
        });
        codeContent.style.display = tabName === 'code' ? 'block' : 'none';
        pseudoContent.style.display = tabName === 'pseudo' ? 'block' : 'none';
    }

    function updateSpeed() {
        animationState.speed = calculateDelay(speedSlider.value);
        console.log(`Animation speed set to: ${animationState.speed}ms`);
        if (animationState.isPlaying) {
            clearTimeout(animationState.timerId);
            playAnimation(); // Restart loop with new speed
        }
    }

    function togglePlayPause() {
        if (animationState.isPlaying) {
            console.log("Pausing animation.");
            pauseAnimation();
        } else {
            console.log("Playing animation.");
            playAnimation();
        }
    }

    function playAnimation() {
        if (!currentAlgorithm || animationState.isPlaying || animationState.currentStep >= animationState.steps.length - 1) {
            if (animationState.currentStep >= animationState.steps.length - 1) {
                console.log("Play called but already at the end.");
                pauseAnimation();
            }
            return;
        }

        animationState.isPlaying = true;
        playPauseBtn.textContent = 'Pause';
        playPauseBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
        playPauseBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
        updateButtonStates();

        function step() {
            if (!animationState.isPlaying) return;

            if (animationState.currentStep < animationState.steps.length - 1) {
                animationState.currentStep++;
                try {
                    currentAlgorithm.renderStep(animationState.steps[animationState.currentStep], animationState.elements, animationState);
                    statusMessage.textContent = animationState.steps[animationState.currentStep]?.message || '';
                } catch (error) {
                     console.error(`Error rendering step ${animationState.currentStep} for ${currentAlgorithm.name}:`, error);
                     statusMessage.textContent = `Error on step ${animationState.currentStep + 1}`;
                     pauseAnimation();
                     return;
                }
                updateButtonStates();
                animationState.timerId = setTimeout(step, animationState.speed);
            } else {
                console.log("Animation finished.");
                pauseAnimation();
            }
        }
        animationState.timerId = setTimeout(step, animationState.speed);
    }

    function pauseAnimation() {
        animationState.isPlaying = false;
        playPauseBtn.textContent = 'Play';
        playPauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
        playPauseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
        clearTimeout(animationState.timerId);
        animationState.timerId = null;
        updateButtonStates();
    }

    function stepForward() {
        if (!currentAlgorithm || animationState.isPlaying || !animationState.steps.length || animationState.currentStep >= animationState.steps.length - 1) {
            console.log("Cannot step forward.");
            return;
        }
        pauseAnimation();
        animationState.currentStep++;
        console.log(`Stepping forward to step: ${animationState.currentStep}`);
        try {
            currentAlgorithm.renderStep(animationState.steps[animationState.currentStep], animationState.elements, animationState);
            statusMessage.textContent = animationState.steps[animationState.currentStep]?.message || '';
        } catch (error) {
             console.error(`Error rendering step ${animationState.currentStep} for ${currentAlgorithm.name}:`, error);
             statusMessage.textContent = `Error on step ${animationState.currentStep + 1}`;
        }
        updateButtonStates();
    }

    function stepBack() {
        if (!currentAlgorithm || animationState.isPlaying || !animationState.steps.length || animationState.currentStep <= 0) {
            console.log("Cannot step back.");
            return;
        }
        pauseAnimation();
        animationState.currentStep--;
        console.log(`Stepping back to step: ${animationState.currentStep}`);
         try {
            currentAlgorithm.renderStep(animationState.steps[animationState.currentStep], animationState.elements, animationState);
            statusMessage.textContent = animationState.steps[animationState.currentStep]?.message || '';
         } catch (error) {
             console.error(`Error rendering step ${animationState.currentStep} for ${currentAlgorithm.name}:`, error);
             statusMessage.textContent = `Error on step ${animationState.currentStep + 1}`;
         }
        updateButtonStates();
    }

    function resetToStart() {
        if (!currentAlgorithm || animationState.steps.length === 0) {
            console.log("Nothing to reset.");
            return;
        }
        console.log("Resetting to start (step 0).");
        pauseAnimation();
        animationState.currentStep = 0;
        try {
            currentAlgorithm.renderStep(animationState.steps[0], animationState.elements, animationState);
            statusMessage.textContent = animationState.steps[0]?.message || 'Ready';
        } catch (error) {
             console.error(`Error rendering step 0 for ${currentAlgorithm.name}:`, error);
             statusMessage.textContent = `Error on step 1`;
        }
        updateButtonStates();
    }

    function handleGenerateData() {
        if (!currentAlgorithmKey) {
            statusMessage.textContent = "Please select an algorithm first.";
            return;
        }
        console.log(`Generating new data for: ${currentAlgorithmKey}`);
        currentData = generateSampleData(currentAlgorithmKey);
        setupVisualization();
    }

    function updateButtonStates() {
        const stepsAvailable = animationState.steps.length > 0;
        const isAtStart = !stepsAvailable || animationState.currentStep <= 0;
        const isAtEnd = !stepsAvailable || animationState.currentStep >= animationState.steps.length - 1;

        playPauseBtn.disabled = !stepsAvailable || isAtEnd || !currentAlgorithm;
        stepForwardBtn.disabled = !stepsAvailable || isAtEnd || animationState.isPlaying || !currentAlgorithm;
        stepBackBtn.disabled = !stepsAvailable || isAtStart || animationState.isPlaying || !currentAlgorithm;
        resetBtn.disabled = !stepsAvailable || isAtStart || animationState.isPlaying || !currentAlgorithm;
        generateDataBtn.disabled = !currentAlgorithmKey || animationState.isPlaying;

        if (stepsAvailable && isAtEnd && !animationState.isPlaying) {
            playPauseBtn.textContent = 'Done';
            playPauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
            playPauseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
        } else if (!animationState.isPlaying) {
            playPauseBtn.textContent = 'Play';
            playPauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
            playPauseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
        } else {
            playPauseBtn.textContent = 'Pause';
            playPauseBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            playPauseBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
        }

        const buttonsToStyle = [playPauseBtn, stepForwardBtn, stepBackBtn, resetBtn, generateDataBtn];
        buttonsToStyle.forEach(btn => {
            if (btn.disabled) {
                btn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                btn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        });
    }

    // --- Event Listeners ---
    algoNav.addEventListener('click', (e) => {
        if (e.target.tagName === 'A' && e.target.dataset.algo) {
            e.preventDefault();
            const algoKey = e.target.dataset.algo;
            console.log(`Sidebar link clicked: ${algoKey}`);
            document.querySelectorAll('#algo-nav a.active').forEach(a => a.classList.remove('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300', 'font-semibold', 'active'));
            e.target.classList.add('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300', 'font-semibold', 'active');
            selectAlgorithm(algoKey);
        } else if (e.target.tagName === 'SUMMARY') {
           // Allow details/summary toggle
        } else {
             e.preventDefault();
        }
    });

    darkModeToggle.addEventListener('change', () => {
        if (darkModeToggle.checked) {
            document.documentElement.classList.add('dark');
            localStorage.setItem('darkMode', 'enabled');
            console.log("Dark mode enabled");
        } else {
            document.documentElement.classList.remove('dark');
            localStorage.setItem('darkMode', 'disabled');
            console.log("Dark mode disabled");
        }
    });

    tabButtons.forEach(button => {
        button.addEventListener('click', () => switchTab(button.dataset.tab));
    });

    playPauseBtn.addEventListener('click', togglePlayPause);
    stepForwardBtn.addEventListener('click', stepForward);
    stepBackBtn.addEventListener('click', stepBack);
    resetBtn.addEventListener('click', resetToStart);
    generateDataBtn.addEventListener('click', handleGenerateData);
    speedSlider.addEventListener('input', updateSpeed);

    // --- Initial Setup ---
    if (localStorage.getItem('darkMode') === 'enabled' ||
       (localStorage.getItem('darkMode') === null && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        darkModeToggle.checked = true;
        document.documentElement.classList.add('dark');
    } else {
        darkModeToggle.checked = false;
        document.documentElement.classList.remove('dark');
    }

    animationState.speed = calculateDelay(speedSlider.value);
    switchTab('code');
    resetVisualizationState();
    console.log("Algorithm Visualizer Initialized (Refactored).");

}); // End DOMContentLoaded
// js/main.js

document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const algoNav = document.getElementById('algo-nav');
    const currentAlgoTitle = document.getElementById('current-algo-title');
    const visualizationArea = document.getElementById('visualization-area');
    const extraVisualizationArea = document.getElementById('extra-visualization-area');
    const codeBlock = document.getElementById('code-block');
    const pseudoBlock = document.getElementById('pseudo-block');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const stepForwardBtn = document.getElementById('step-forward-btn');
    const stepBackBtn = document.getElementById('step-back-btn');
    const resetBtn = document.getElementById('reset-btn');
    const generateDataBtn = document.getElementById('generate-data-btn');
    const speedSlider = document.getElementById('speed-slider');
    const codeContent = document.getElementById('code-content');
    const pseudoContent = document.getElementById('pseudo-content');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const statusMessage = document.getElementById('status-message');
    const tabButtons = document.querySelectorAll('.tab-btn');

    // --- State Variables ---
    let currentAlgorithmKey = null;
    let currentAlgorithm = null; // Will reference an object from algorithms.js
    let currentData = [];
    let animationState = {
        steps: [],           // Array of step objects generated by algorithm setup
        elements: [],        // Array of DOM elements for main visualization (e.g., bars)
        countElements: [],   // Array of DOM elements for count array (if used)
        outputElements: [],  // Array of DOM elements for output array (if used)
        currentStep: -1,     // Index of the current step being displayed
        isPlaying: false,    // Is the animation currently playing?
        timerId: null,       // ID for setTimeout used in play mode
        speed: 500,          // Current animation delay (initialized later)
        targetValue: null,   // Target value for search algorithms
    };

    // NOTE: The 'algorithms' constant is globally available because algorithms.js was loaded first.

    // --- Default/Placeholder Functions ---
    // These are assigned to algorithms in the loop below if they don't provide their own
    function defaultSetup(data) {
        const algoName = this && this.name ? this.name : 'Algorithm'; // 'this' is bound to the algorithm object
        const visArea = document.getElementById('visualization-area'); // Re-select within function scope
        const extraVisArea = document.getElementById('extra-visualization-area');
        if (visArea) visArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">${algoName} visualization not implemented yet.</p>`;
        if (extraVisArea) extraVisArea.innerHTML = '';
        if (statusMessage) statusMessage.textContent = 'Visualization not implemented.';
        // Return empty structure matching what setup usually returns
        return { steps: [], elements: [], countElements: [], outputElements: [], target: null };
    }

    function defaultRender(step, elements, animationState) {
        if (statusMessage) statusMessage.textContent = 'Rendering logic not implemented for this step.';
    }

    // --- Initialize Algorithms with Defaults ---
    // Iterate through the globally available 'algorithms' object
    for (const key in algorithms) {
        if (algorithms.hasOwnProperty(key)) {
            // Assign default setup ONLY if setup is null or undefined
            if (!algorithms[key].setup) {
                algorithms[key].setup = defaultSetup.bind(algorithms[key]); // Bind 'this' context
            }
            // Assign default renderStep ONLY if renderStep is null or undefined
            if (!algorithms[key].renderStep) {
                algorithms[key].renderStep = defaultRender;
            }
        }
    }

    // --- Helper Functions ---
    function calculateDelay(sliderValue) {
        const minDelay = 50; // ms (fastest)
        const maxDelay = 1500; // ms (slowest)
        // Ensure slider value is within range (1-10)
        const value = Math.max(1, Math.min(10, sliderValue));
        // Linear interpolation reversed: higher slider value -> lower delay
        return maxDelay - (value - 1) * (maxDelay - minDelay) / (10 - 1);
    }

    function generateSampleData(algoKey) {
        const size = 20; // Default size
        let minVal = 10;
        let maxVal = 100;
        let onlyPositiveInts = false;
        let requiresSorted = false;

        // Check algorithm-specific requirements
        if (algorithms[algoKey]) {
            if (algorithms[algoKey].requiresPositiveInts) {
                onlyPositiveInts = true;
                minVal = 0; // Counting sort needs 0+
                maxVal = 50; // Keep range smaller for count array vis
            }
            if (algorithms[algoKey].requiresSortedData) {
                requiresSorted = true;
            }
        }

        // Generate random data
        let data = Array.from({ length: size }, () => {
            let val = Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal;
            return onlyPositiveInts ? Math.max(0, val) : val; // Ensure positive if needed
        });

        // Sort if required
        if (requiresSorted) {
            data.sort((a, b) => a - b);
        }
        console.log("Generated data:", data); // Log generated data for debugging
        return data;
    }

    // --- Core Application Logic ---
    function selectAlgorithm(algoKey) {
        console.log(`Attempting to select algorithm: ${algoKey}`);
        if (!algorithms[algoKey]) {
            console.error(`Algorithm "${algoKey}" not found in definitions.`);
            resetVisualizationState(); // Reset state first
            currentAlgoTitle.textContent = 'Algorithm Not Found';
            codeBlock.innerHTML = '// Algorithm definition missing';
            pseudoBlock.textContent = '// Algorithm definition missing';
            visualizationArea.innerHTML = `<p class="text-red-500 dark:text-red-400 self-center">Error: Algorithm '${algoKey}' definition missing.</p>`;
            extraVisualizationArea.innerHTML = '';
            updateButtonStates(); // Disable buttons
            return;
        }

        pauseAnimation(); // Stop any ongoing animation
        currentAlgorithmKey = algoKey;
        currentAlgorithm = algorithms[algoKey]; // Get the object from algorithms.js
        currentData = generateSampleData(currentAlgorithmKey); // Generate data suitable for this algo

        console.log(`Selected: ${currentAlgorithm.name}`);
        currentAlgoTitle.textContent = currentAlgorithm.name;
        codeBlock.innerHTML = currentAlgorithm.code || '// Code not available'; // Use innerHTML for code
        pseudoBlock.textContent = currentAlgorithm.pseudocode || '// Pseudocode not available';

        // Setup the visualization using the algorithm's setup function
        setupVisualization();
    }

    function setupVisualization() {
        if (!currentAlgorithm || !currentData) {
            console.warn("Setup called without algorithm or data.");
            visualizationArea.innerHTML = '<p class="text-gray-500 dark:text-gray-400 self-center">Select an Algorithm</p>';
            extraVisualizationArea.innerHTML = '';
            statusMessage.textContent = 'Error: No algorithm selected for setup.';
            updateButtonStates();
            return;
        }

        console.log(`Setting up visualization for: ${currentAlgorithm.name}`);

        // Reset parts of animation state but keep speed/isPlaying status
        animationState = {
            ...animationState, // Keep speed, isPlaying etc.
            steps: [],
            elements: [],
            countElements: [],
            outputElements: [],
            currentStep: -1,
            targetValue: null,
        };
        visualizationArea.innerHTML = ''; // Clear previous visualization
        extraVisualizationArea.innerHTML = ''; // Clear extra area


        try {
            // Call the setup function defined in algorithms.js for the current algorithm
            // The setup function is responsible for creating DOM elements and steps
            const setupResult = currentAlgorithm.setup(currentData);

            // Store the results (DOM elements, steps) in the animationState
            animationState.steps = setupResult.steps || [];
            animationState.elements = setupResult.elements || [];
            animationState.countElements = setupResult.countElements || []; // Specific for Counting Sort etc.
            animationState.outputElements = setupResult.outputElements || []; // Specific for Counting Sort etc.
            animationState.targetValue = setupResult.target; // Specific for Search Algos

            console.log(`Setup generated ${animationState.steps.length} steps.`);

            if (animationState.steps.length > 0) {
                animationState.currentStep = 0;
                // Render the initial step (step 0) using the algorithm's renderStep function
                currentAlgorithm.renderStep(animationState.steps[0], animationState.elements, animationState);
                statusMessage.textContent = animationState.steps[0]?.message || 'Ready'; // Show initial message
            } else if (!visualizationArea.innerHTML.includes('visualization not implemented yet') && !visualizationArea.innerHTML.includes('requires non-negative integers')) {
                 // Only show this if setup didn't already put a message there
                visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">No visualization steps generated.</p>`;
                extraVisualizationArea.innerHTML = '';
                statusMessage.textContent = 'No steps to visualize.';
            } else {
                 // If setup put a message (like "not implemented"), keep it and clear status
                 // Status is already set by defaultSetup in this case
            }
        } catch (error) {
            console.error(`Error during setup for ${currentAlgorithm.name}:`, error);
            visualizationArea.innerHTML = `<p class="text-red-500 dark:text-red-400 self-center">Error during setup. Check console.</p>`;
            extraVisualizationArea.innerHTML = '';
            statusMessage.textContent = 'Error during setup';
            // Reset crucial state parts on error to prevent further issues
            animationState.steps = [];
            animationState.elements = [];
            animationState.countElements = [];
            animationState.outputElements = [];
            animationState.currentStep = -1;
        }

        updateButtonStates(); // Update buttons based on the new state
    }

    function resetVisualizationState() {
        console.log("Resetting visualization state.");
        pauseAnimation(); // Stop any animation
        currentAlgorithmKey = null;
        currentAlgorithm = null;
        currentData = [];
        // Reset animation state, keeping the current speed setting
        animationState = {
            ...animationState, // Keep speed
            steps: [], elements: [], countElements: [], outputElements: [],
            currentStep: -1, isPlaying: false, timerId: null, targetValue: null,
        };
        // Reset UI elements
        visualizationArea.innerHTML = '<p class="text-gray-500 dark:text-gray-400 self-center">Select an Algorithm</p>';
        extraVisualizationArea.innerHTML = '';
        currentAlgoTitle.textContent = 'Select an Algorithm';
        codeBlock.innerHTML = '// Select an algorithm to view the code';
        pseudoBlock.textContent = '// Select an algorithm to view the pseudocode';
        statusMessage.textContent = '';
        updateButtonStates(); // Disable buttons appropriately
        // Deselect any active algorithm in the sidebar
        document.querySelectorAll('#algo-nav a.active').forEach(a => a.classList.remove('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300', 'font-semibold', 'active'));
    }

    function switchTab(tabName) {
        console.log(`Switching tab to: ${tabName}`);
        tabButtons.forEach(button => {
            const isActive = button.dataset.tab === tabName;
            // Use Tailwind classes for active/inactive state styling defined in index.html/style.css
            button.classList.toggle('active', isActive); // Keep logical active class if needed elsewhere
            button.classList.toggle('border-blue-500', isActive);
            button.classList.toggle('text-blue-600', isActive);
            button.classList.toggle('dark:text-blue-400', isActive);
            button.classList.toggle('border-transparent', !isActive);
            button.classList.toggle('text-gray-500', !isActive);
            button.classList.toggle('dark:text-gray-400', !isActive);
            button.classList.toggle('hover:text-gray-700', !isActive);
            button.classList.toggle('dark:hover:text-gray-300', !isActive);
            button.classList.toggle('hover:border-gray-300', !isActive);
            button.classList.toggle('dark:hover:border-gray-600', !isActive);
        });
        // Toggle display of content areas
        codeContent.style.display = tabName === 'code' ? 'block' : 'none';
        pseudoContent.style.display = tabName === 'pseudo' ? 'block' : 'none';
    }

    function updateSpeed() {
        animationState.speed = calculateDelay(speedSlider.value);
        console.log(`Animation speed set to: ${animationState.speed}ms`);
        // If currently playing, restart the timer loop with the new speed
        if (animationState.isPlaying) {
            clearTimeout(animationState.timerId); // Stop the old timer
            playAnimation(); // Restart play which uses the new speed
        }
    }

    function togglePlayPause() {
        if (animationState.isPlaying) {
            console.log("Pausing animation.");
            pauseAnimation();
        } else {
            console.log("Playing animation.");
            playAnimation();
        }
    }

    function playAnimation() {
        // Prevent starting if no algo, already playing, or at the end
        if (!currentAlgorithm || animationState.isPlaying || animationState.currentStep >= animationState.steps.length - 1) {
            if (animationState.currentStep >= animationState.steps.length - 1) {
                console.log("Play called but already at the end.");
                pauseAnimation(); // Ensure state is paused if trying to play at the end
            }
            return;
        }

        animationState.isPlaying = true;
        playPauseBtn.textContent = 'Pause';
        playPauseBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
        playPauseBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
        updateButtonStates(); // Disable step buttons etc.

        // --- Animation Loop ---
        function step() {
            if (!animationState.isPlaying) return; // Stop if paused externally between steps

            if (animationState.currentStep < animationState.steps.length - 1) {
                animationState.currentStep++;
                // Call the algorithm-specific renderStep
                try {
                    currentAlgorithm.renderStep(animationState.steps[animationState.currentStep], animationState.elements, animationState);
                    statusMessage.textContent = animationState.steps[animationState.currentStep]?.message || ''; // Update status message
                } catch (error) {
                     console.error(`Error rendering step ${animationState.currentStep} for ${currentAlgorithm.name}:`, error);
                     statusMessage.textContent = `Error on step ${animationState.currentStep + 1}`;
                     pauseAnimation();
                     return;
                }

                updateButtonStates(); // Update buttons after the step
                // Schedule the next step
                animationState.timerId = setTimeout(step, animationState.speed);
            } else {
                // Reached the end of the animation
                console.log("Animation finished.");
                pauseAnimation(); // Set state to paused, update buttons
            }
        }
        // --- End Animation Loop ---

        // Start the stepping process
        animationState.timerId = setTimeout(step, animationState.speed);
    }

    function pauseAnimation() {
        animationState.isPlaying = false;
        playPauseBtn.textContent = 'Play';
        playPauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
        playPauseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
        clearTimeout(animationState.timerId); // Clear any pending step timer
        animationState.timerId = null;
        updateButtonStates(); // Re-enable step buttons etc.
    }

    function stepForward() {
        // Can only step forward if steps exist, not at end, and not playing
        if (!currentAlgorithm || animationState.isPlaying || !animationState.steps.length || animationState.currentStep >= animationState.steps.length - 1) {
            console.log("Cannot step forward.");
            return;
        }
        pauseAnimation(); // Ensure paused before manual step
        animationState.currentStep++;
        console.log(`Stepping forward to step: ${animationState.currentStep}`);
        try {
            currentAlgorithm.renderStep(animationState.steps[animationState.currentStep], animationState.elements, animationState);
            statusMessage.textContent = animationState.steps[animationState.currentStep]?.message || '';
        } catch (error) {
             console.error(`Error rendering step ${animationState.currentStep} for ${currentAlgorithm.name}:`, error);
             statusMessage.textContent = `Error on step ${animationState.currentStep + 1}`;
        }
        updateButtonStates();
    }

    function stepBack() {
        // Can only step back if steps exist, not at start, and not playing
        if (!currentAlgorithm || animationState.isPlaying || !animationState.steps.length || animationState.currentStep <= 0) {
            console.log("Cannot step back.");
            return;
        }
        pauseAnimation(); // Ensure paused before manual step
        animationState.currentStep--;
        console.log(`Stepping back to step: ${animationState.currentStep}`);
         try {
            currentAlgorithm.renderStep(animationState.steps[animationState.currentStep], animationState.elements, animationState);
            statusMessage.textContent = animationState.steps[animationState.currentStep]?.message || '';
         } catch (error) {
             console.error(`Error rendering step ${animationState.currentStep} for ${currentAlgorithm.name}:`, error);
             statusMessage.textContent = `Error on step ${animationState.currentStep + 1}`;
         }

        updateButtonStates();
    }

    function resetToStart() {
        if (!currentAlgorithm || animationState.steps.length === 0) {
            console.log("Nothing to reset.");
            return; // Nothing to reset to
        }
        console.log("Resetting to start (step 0).");
        pauseAnimation(); // Ensure paused
        animationState.currentStep = 0;
        // Render the very first step
        try {
            currentAlgorithm.renderStep(animationState.steps[0], animationState.elements, animationState);
            statusMessage.textContent = animationState.steps[0]?.message || 'Ready';
        } catch (error) {
             console.error(`Error rendering step 0 for ${currentAlgorithm.name}:`, error);
             statusMessage.textContent = `Error on step 1`;
        }
        updateButtonStates();
    }

    function handleGenerateData() {
        if (!currentAlgorithmKey) {
            statusMessage.textContent = "Please select an algorithm first.";
            // Optionally flash the sidebar or algorithm title
            return;
        }
        console.log(`Generating new data for: ${currentAlgorithmKey}`);
        // Regenerate data respecting the current algorithm's requirements
        currentData = generateSampleData(currentAlgorithmKey);
        // Setup the visualization with the new data (this pauses, resets steps, renders step 0)
        setupVisualization();
    }

    function updateButtonStates() {
        const stepsAvailable = animationState.steps.length > 0;
        const isAtStart = !stepsAvailable || animationState.currentStep <= 0;
        const isAtEnd = !stepsAvailable || animationState.currentStep >= animationState.steps.length - 1;

        // Enable/Disable based on state
        playPauseBtn.disabled = !stepsAvailable || isAtEnd || !currentAlgorithm;
        stepForwardBtn.disabled = !stepsAvailable || isAtEnd || animationState.isPlaying || !currentAlgorithm;
        stepBackBtn.disabled = !stepsAvailable || isAtStart || animationState.isPlaying || !currentAlgorithm;
        resetBtn.disabled = !stepsAvailable || isAtStart || animationState.isPlaying || !currentAlgorithm; // Also disable reset if playing
        generateDataBtn.disabled = !currentAlgorithmKey || animationState.isPlaying; // Disable generate if playing or no algo selected

        // Update Play/Pause text and style
        if (stepsAvailable && isAtEnd && !animationState.isPlaying) {
            playPauseBtn.textContent = 'Done';
            playPauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
            playPauseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
        } else if (!animationState.isPlaying) {
            playPauseBtn.textContent = 'Play';
            playPauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
            playPauseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
        } else { // Is playing
            playPauseBtn.textContent = 'Pause';
            playPauseBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            playPauseBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
        }

        // Apply Tailwind disabled styles automatically via :disabled pseudo-class (should be default)
        // Or manually add/remove opacity/cursor classes if needed for older browser support or specific styling:
        const buttonsToStyle = [playPauseBtn, stepForwardBtn, stepBackBtn, resetBtn, generateDataBtn];
        buttonsToStyle.forEach(btn => {
            if (btn.disabled) {
                btn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                btn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        });
    }

    // --- Event Listeners ---
    // Algorithm selection from sidebar
    algoNav.addEventListener('click', (e) => {
        if (e.target.tagName === 'A' && e.target.dataset.algo) {
            e.preventDefault(); // Prevent default anchor behavior (#)
            const algoKey = e.target.dataset.algo;
            console.log(`Sidebar link clicked: ${algoKey}`);

            // Deselect previous active link
            document.querySelectorAll('#algo-nav a.active').forEach(a => a.classList.remove('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300', 'font-semibold', 'active'));

            // Select the new link visually
            e.target.classList.add('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300', 'font-semibold', 'active');

            // Load and set up the selected algorithm
            selectAlgorithm(algoKey);
        } else if (e.target.tagName === 'SUMMARY') {
            // Allow details/summary toggle to work naturally
        } else {
             e.preventDefault(); // Prevent other clicks in nav from doing anything unexpected
        }
    });

    // Dark Mode Toggle
    darkModeToggle.addEventListener('change', () => {
        if (darkModeToggle.checked) {
            document.documentElement.classList.add('dark');
            localStorage.setItem('darkMode', 'enabled');
            console.log("Dark mode enabled");
        } else {
            document.documentElement.classList.remove('dark');
            localStorage.setItem('darkMode', 'disabled');
            console.log("Dark mode disabled");
        }
    });

    // Tabs (Code/Pseudocode)
    tabButtons.forEach(button => {
        button.addEventListener('click', () => switchTab(button.dataset.tab));
    });

    // Control Buttons
    playPauseBtn.addEventListener('click', togglePlayPause);
    stepForwardBtn.addEventListener('click', stepForward);
    stepBackBtn.addEventListener('click', stepBack);
    resetBtn.addEventListener('click', resetToStart);
    generateDataBtn.addEventListener('click', handleGenerateData);

    // Speed Slider
    speedSlider.addEventListener('input', updateSpeed); // 'input' fires continuously

    // --- Initial Setup ---
    // Check local storage for theme preference on load
    if (localStorage.getItem('darkMode') === 'enabled' ||
       (localStorage.getItem('darkMode') === null && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        darkModeToggle.checked = true;
        document.documentElement.classList.add('dark');
    } else {
        darkModeToggle.checked = false;
        document.documentElement.classList.remove('dark');
    }

    // Set initial speed from slider default value
    animationState.speed = calculateDelay(speedSlider.value);

    // Set initial tab state
    switchTab('code'); // Default to code tab

    // Start with a clean slate and disabled buttons
    resetVisualizationState();

    console.log("Algorithm Visualizer Initialized.");

}); // End DOMContentLoaded
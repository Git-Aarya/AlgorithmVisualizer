<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <style>
        /* Apply Inter font globally */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for sidebar (optional) */
        .sidebar-scroll::-webkit-scrollbar { width: 6px; }
        .sidebar-scroll::-webkit-scrollbar-track { background: transparent; }
        .sidebar-scroll::-webkit-scrollbar-thumb { background-color: rgba(156, 163, 175, 0.5); border-radius: 3px; }
        .dark .sidebar-scroll::-webkit-scrollbar-thumb { background-color: rgba(107, 114, 128, 0.5); }

        /* Visualization Bar Styling */
        .vis-bar {
            display: inline-block;
            background-color: #3b82f6; /* blue-500 */
            margin: 0 1px;
            width: 15px;
            vertical-align: bottom;
            transition: height 0.3s ease-in-out, background-color 0.3s ease-in-out, opacity 0.3s ease-in-out, border 0.1s ease-in-out, transform 0.3s ease-in-out;
            border-radius: 4px 4px 0 0;
            position: relative;
            text-align: center;
            color: white;
            font-size: 10px;
            line-height: 1;
            border: 1px solid transparent; /* Base border */
        }
        .dark .vis-bar { background-color: #60a5fa; /* blue-400 */ }

        /* General comparison/mid-point highlight */
        .vis-bar.comparing {
            background-color: #facc15; /* yellow-400 */
            border-color: #eab308; /* yellow-500 */
        }
        .dark .vis-bar.comparing {
            background-color: #fde047; /* yellow-300 */
            border-color: #facc15; /* yellow-400 */
        }
        /* Swapping highlight (Sorting) */
        .vis-bar.swapping {
            background-color: #f87171; /* red-400 */
            border-color: #ef4444; /* red-500 */
        }
        .dark .vis-bar.swapping {
            background-color: #ef4444; /* red-500 */
            border-color: #dc2626; /* red-600 */
        }
        /* Sorted element highlight (General Sorting) */
         .vis-bar.sorted-pass { /* Used in Bubble sort pass */
            background-color: #a3e635; /* lime-400 */
        }
        .dark .vis-bar.sorted-pass { background-color: #bef264; /* lime-300 */ }
        .vis-bar.sorted-final { /* Final sorted state */
            background-color: #4ade80; /* green-400 */
        }
        .dark .vis-bar.sorted-final { background-color: #86efac; /* green-300 */ }

        /* Found element highlight (Searching) */
        .vis-bar.found {
            background-color: #fb923c; /* orange-400 */
            border: 2px solid #f97316; /* orange-500 */
        }
        .dark .vis-bar.found {
            background-color: #fdba74; /* orange-300 */
             border: 2px solid #ea580c; /* orange-600 */
        }
         /* Dimmed/Checked/Out-of-range element */
        .vis-bar.checked, .vis-bar.out-of-range, .vis-bar.outside-partition, .vis-bar.outside-heap-range, .vis-bar.outside-merge-range { opacity: 0.4; }
        /* Highlight for the current search/partition range */
        .vis-bar.in-range, .vis-bar.partition-range, .vis-bar.heap-range, .vis-bar.merge-range { /* No specific style, relies on dimming */ }

        /* == Selection Sort Specific Styles == */
        .vis-bar.current-outer { border-bottom: 3px solid #a855f7; } /* purple-500 */
        .dark .vis-bar.current-outer { border-bottom-color: #c084fc; } /* purple-400 */
        .vis-bar.minimum { background-color: #ec4899; border-color: #db2777; } /* pink-500/600 */
        .dark .vis-bar.minimum { background-color: #f9a8d4; border-color: #ec4899; } /* pink-300/500 */

        /* == Insertion Sort Specific Styles == */
        .vis-bar.current-insertion { border: 2px solid #f43f5e; transform: translateY(-10px); } /* rose-500 */
        .dark .vis-bar.current-insertion { border-color: #fb7185; } /* rose-400 */
        .vis-bar.shifting { opacity: 0.7; background-color: #6366f1; } /* indigo-500 */
         .dark .vis-bar.shifting { background-color: #818cf8; } /* indigo-400 */

        /* == Quick Sort Specific Styles == */
        .vis-bar.pivot { border: 2px dashed #f43f5e; } /* rose-500 dashed border */
        .dark .vis-bar.pivot { border-color: #fb7185; } /* rose-400 */
        .vis-bar.partition-i::before { content: 'i'; position: absolute; top: -18px; left: 50%; transform: translateX(-50%); font-size: 12px; font-weight: bold; color: #a855f7; } /* purple-500 */
         .dark .vis-bar.partition-i::before { color: #c084fc; } /* purple-400 */
        .vis-bar.partition-j::after { content: 'j'; position: absolute; bottom: -18px; left: 50%; transform: translateX(-50%); font-size: 12px; font-weight: bold; color: #22c55e; } /* green-500 */
        .dark .vis-bar.partition-j::after { color: #4ade80; } /* green-400 */
        .vis-bar.sorted-partition { background-color: #22d3ee; } /* cyan-400 */
        .dark .vis-bar.sorted-partition { background-color: #67e8f9; } /* cyan-300 */

        /* == Merge Sort Specific Styles == */
        .vis-bar.placing-merge { background-color: #6366f1; border-color: #4f46e5; } /* indigo-500/600 */
         .dark .vis-bar.placing-merge { background-color: #818cf8; border-color: #6366f1; } /* indigo-400/500 */

        /* == Heap Sort Specific Styles == */
        .vis-bar.heapify-node { border: 2px solid #fbbf24; /* amber-400 */ }
        .dark .vis-bar.heapify-node { border-color: #fcd34d; /* amber-300 */ }
        .vis-bar.heapify-largest { background-color: #f87171; /* red-400 */ }
        .dark .vis-bar.heapify-largest { background-color: #ef4444; /* red-500 */ }

        /* == Counting Sort Specific Styles == */
        .vis-bar.reading { background-color: #fb923c; } /* orange-400 */
        .dark .vis-bar.reading { background-color: #fdba74; } /* orange-300 */
        .vis-bar.writing { background-color: #a3e635; } /* lime-400 */
        .dark .vis-bar.writing { background-color: #bef264; /* lime-300 */ }

        .count-array-vis, .output-array-vis {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 10px;
            padding: 8px;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 6px;
            background-color: #f9fafb; /* gray-50 */
            min-height: 40px;
            align-items: center;
            position: relative; /* For label */
        }
        .dark .count-array-vis, .dark .output-array-vis {
            border-color: #4b5563; /* gray-600 */
            background-color: #374151; /* gray-700 */
        }
        .count-array-vis::before, .output-array-vis::before {
            content: attr(data-label);
            position: absolute;
            top: -10px;
            left: 5px;
            font-size: 0.75rem;
            font-weight: 500;
            color: #6b7280; /* gray-500 */
            background-color: #f9fafb; /* gray-50 */
            padding: 0 4px;
        }
        .dark .count-array-vis::before, .dark .output-array-vis::before {
            color: #d1d5db; /* gray-300 */
            background-color: #374151; /* gray-700 */
        }

        .count-cell, .output-cell {
            min-width: 25px;
            height: 25px;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 11px;
            background-color: #fff; /* white */
            transition: background-color 0.3s ease-in-out, border-color 0.3s ease-in-out, transform 0.2s ease-in-out;
            position: relative; /* For index label */
        }
        .dark .count-cell, .dark .output-cell {
            border-color: #6b7280; /* gray-500 */
            background-color: #4b5563; /* gray-600 */
        }
        .count-cell::after, .output-cell::after {
            content: attr(data-index);
            position: absolute;
            bottom: -14px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            color: #9ca3af; /* gray-400 */
        }
        .dark .count-cell::after, .dark .output-cell::after {
            color: #6b7280; /* gray-500 */
        }

        .count-cell.highlight-read, .output-cell.highlight-read {
            border-color: #fb923c; /* orange-400 */
            transform: scale(1.1);
        }
        .count-cell.highlight-write, .output-cell.highlight-write {
            background-color: #a3e635; /* lime-400 */
            border-color: #84cc16; /* lime-500 */
            transform: scale(1.1);
        }
        .dark .count-cell.highlight-write, .dark .output-cell.highlight-write {
             background-color: #bef264; /* lime-300 */
             border-color: #a3e635; /* lime-400 */
        }
        .output-cell.empty {
            background-color: #e5e7eb; /* gray-200 */
            color: #9ca3af; /* gray-400 */
        }
        .dark .output-cell.empty {
            background-color: #4b5563; /* gray-600 */
            color: #6b7280; /* gray-500 */
        }


        /* Ensure code block respects dark mode */
        .dark pre { background-color: #1f2937; color: #d1d5db; }
        /* Basic syntax highlighting imitation */
        .code-keyword { color: #ec4899; } .dark .code-keyword { color: #f9a8d4; }
        .code-function { color: #8b5cf6; } .dark .code-function { color: #c4b5fd; }
        .code-comment { color: #6b7280; } .dark .code-comment { color: #9ca3af; }
        .code-number { color: #f59e0b; } .dark .code-number { color: #fcd34d; }
        .code-string { color: #10b981; } .dark .code-string { color: #6ee7b7; }

        /* Style details/summary for accordion */
        details > summary { list-style: none; cursor: pointer; }
        details > summary::-webkit-details-marker { display: none; }
        details > summary::before { content: '+'; display: inline-block; width: 1em; margin-right: 0.5em; font-weight: bold; transition: transform 0.2s ease-in-out; }
        details[open] > summary::before { transform: rotate(45deg); }
    </style>
    <script>
        tailwind.config = { darkMode: 'class', theme: { extend: { fontFamily: { sans: ['Inter', 'sans-serif'], }, } } }
    </script>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300">

    <header class="bg-white dark:bg-gray-800 shadow-md sticky top-0 z-10 transition-colors duration-300">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <h1 class="text-2xl font-bold text-blue-600 dark:text-blue-400">Algorithm Visualizer</h1>
            <div class="flex items-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-gray-500 dark:text-gray-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-6.364-.386 1.591-1.591M3 12h2.25m.386-6.364 1.591 1.591" /></svg>
                <label for="darkModeToggle" class="relative inline-flex items-center cursor-pointer"><input type="checkbox" id="darkModeToggle" class="sr-only peer"><div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div></label>
                 <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-gray-500 dark:text-gray-400"><path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" /></svg>
            </div>
        </div>
    </header>

    <div class="flex flex-col md:flex-row min-h-[calc(100vh-64px)]">
        <aside class="w-full md:w-64 lg:w-72 bg-white dark:bg-gray-800 p-4 border-r border-gray-200 dark:border-gray-700 shadow-sm md:shadow-none overflow-y-auto sidebar-scroll transition-colors duration-300 flex-shrink-0">
            <h2 class="text-lg font-semibold mb-4 text-gray-700 dark:text-gray-300">Algorithms</h2>
            <nav id="algo-nav" class="space-y-2">
                <details class="group" open>
                    <summary class="font-medium text-gray-800 dark:text-gray-200 hover:text-blue-600 dark:hover:text-blue-400">Searching & Sorting</summary>
                    <ul class="mt-1 pl-4 space-y-1">
                        <li><a href="#" data-algo="linear-search" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Linear Search</a></li>
                        <li><a href="#" data-algo="binary-search" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Binary Search</a></li>
                        <li><a href="#" data-algo="bubble-sort" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Bubble Sort</a></li>
                        <li><a href="#" data-algo="selection-sort" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Selection Sort</a></li>
                        <li><a href="#" data-algo="insertion-sort" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Insertion Sort</a></li>
                        <li><a href="#" data-algo="merge-sort" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Merge Sort</a></li>
                        <li><a href="#" data-algo="quick-sort" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Quick Sort</a></li>
                        <li><a href="#" data-algo="heap-sort" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Heap Sort</a></li>
                        <li><a href="#" data-algo="counting-sort" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Counting Sort</a></li>
                    </ul>
                </details>
                 <details class="group"> <summary class="font-medium text-gray-800 dark:text-gray-200 hover:text-blue-600 dark:hover:text-blue-400">Tree Algorithms</summary> <ul class="mt-1 pl-4 space-y-1"><li><a href="#" data-algo="tree-traversals" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Tree Traversals</a></li><li><a href="#" data-algo="bst" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Binary Search Tree</a></li><li><a href="#" data-algo="avl" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">AVL Tree Rotations</a></li><li><a href="#" data-algo="heap-ops" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Heap Operations</a></li><li><a href="#" data-algo="tree-bfs-dfs" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">BFS & DFS (Trees)</a></li></ul></details>
                 <details class="group"> <summary class="font-medium text-gray-800 dark:text-gray-200 hover:text-blue-600 dark:hover:text-blue-400">Graph Algorithms</summary> <ul class="mt-1 pl-4 space-y-1"><li><a href="#" data-algo="graph-bfs" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">BFS (Graphs)</a></li><li><a href="#" data-algo="graph-dfs" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">DFS (Graphs)</a></li><li><a href="#" data-algo="dijkstra" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Dijkstra’s Algorithm</a></li><li><a href="#" data-algo="bellman-ford" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Bellman-Ford</a></li><li><a href="#" data-algo="floyd-warshall" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Floyd-Warshall</a></li><li><a href="#" data-algo="kruskal" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Kruskal’s MST</a></li><li><a href="#" data-algo="prim" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Prim’s MST</a></li><li><a href="#" data-algo="topo-sort" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Topological Sorting</a></li></ul></details>
                 <details class="group"> <summary class="font-medium text-gray-800 dark:text-gray-200 hover:text-blue-600 dark:hover:text-blue-400">Dynamic Programming</summary> <ul class="mt-1 pl-4 space-y-1"><li><a href="#" data-algo="fibonacci" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Fibonacci</a></li><li><a href="#" data-algo="lcs" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Longest Common Subsequence</a></li><li><a href="#" data-algo="knapsack" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">0/1 Knapsack</a></li><li><a href="#" data-algo="coin-change" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Coin Change</a></li><li><a href="#" data-algo="mcm" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Matrix Chain Multiplication</a></li></ul></details>
                 <details class="group"> <summary class="font-medium text-gray-800 dark:text-gray-200 hover:text-blue-600 dark:hover:text-blue-400">Backtracking</summary> <ul class="mt-1 pl-4 space-y-1"><li><a href="#" data-algo="n-queens" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">N-Queens</a></li><li><a href="#" data-algo="sudoku" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Sudoku Solver</a></li><li><a href="#" data-algo="rat-maze" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Rat in a Maze</a></li><li><a href="#" data-algo="word-search" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Word Search</a></li></ul></details>
                 <details class="group"> <summary class="font-medium text-gray-800 dark:text-gray-200 hover:text-blue-600 dark:hover:text-blue-400">Miscellaneous</summary> <ul class="mt-1 pl-4 space-y-1"><li><a href="#" data-algo="union-find" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Union-Find</a></li><li><a href="#" data-algo="kmp" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">KMP Algorithm</a></li><li><a href="#" data-algo="rabin-karp" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Rabin-Karp</a></li><li><a href="#" data-algo="sliding-window" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Sliding Window</a></li><li><a href="#" data-algo="two-pointers" class="block text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 rounded px-2 py-1">Two Pointers</a></li></ul></details>
            </nav>
        </aside>

        <main class="flex-1 p-4 md:p-6 lg:p-8 flex flex-col">
            <h2 id="current-algo-title" class="text-2xl font-semibold mb-4 text-center text-gray-800 dark:text-gray-200">Select an Algorithm</h2>

            <div id="visualization-area" class="h-48 md:h-56 lg:h-64 bg-gray-100 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg mb-4 flex justify-center items-end p-4 overflow-hidden transition-colors duration-300 relative">
                 <p class="text-gray-500 dark:text-gray-400 self-center">Visualization appears here</p>
            </div>

            <div id="extra-visualization-area" class="space-y-3 mb-4">
                </div>

            <div id="status-message" class="text-center mb-4 h-6 text-sm text-gray-600 dark:text-gray-400"></div>

            <div class="bg-white dark:bg-gray-800 p-3 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 mb-4 transition-colors duration-300">
                <div class="flex flex-wrap items-center justify-center gap-3 md:gap-4">
                    <button id="generate-data-btn" class="px-3 py-1.5 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed">Generate New Data</button>
                    <button id="reset-btn" class="px-3 py-1.5 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed">Reset</button>
                    <button id="step-back-btn" class="px-3 py-1.5 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed">Step Back</button>
                    <button id="play-pause-btn" class="px-3 py-1.5 text-sm font-medium text-white bg-green-600 hover:bg-green-700 rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed">Play</button>
                    <button id="step-forward-btn" class="px-3 py-1.5 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed">Step Forward</button>
                    <div class="flex items-center space-x-2">
                        <label for="speed-slider" class="text-sm font-medium text-gray-700 dark:text-gray-300">Speed:</label>
                        <input type="range" id="speed-slider" min="1" max="10" value="5" class="w-24 h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                    </div>
                </div>
            </div>

            <div class="flex-grow bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 flex flex-col overflow-hidden transition-colors duration-300">
                <div class="border-b border-gray-200 dark:border-gray-700">
                    <nav class="-mb-px flex space-x-4 px-4" aria-label="Tabs">
                        <button class="tab-btn active" data-tab="code">Code</button>
                        <button class="tab-btn" data-tab="pseudo">Pseudocode</button>
                    </nav>
                </div>
                <div class="flex-grow overflow-auto p-4">
                    <div id="code-content" class="tab-content active">
                        <pre class="text-sm rounded-md bg-gray-50 dark:bg-gray-900 p-4 overflow-x-auto"><code class="language-javascript" id="code-block">// Select an algorithm to view the code</code></pre>
                    </div>
                    <div id="pseudo-content" class="tab-content">
                        <pre class="text-sm rounded-md bg-gray-50 dark:bg-gray-900 p-4 overflow-x-auto"><code id="pseudo-block">// Select an algorithm to view the pseudocode</code></pre>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const algoNav = document.getElementById('algo-nav');
            const currentAlgoTitle = document.getElementById('current-algo-title');
            const visualizationArea = document.getElementById('visualization-area');
            const extraVisualizationArea = document.getElementById('extra-visualization-area'); // Added
            const codeBlock = document.getElementById('code-block');
            const pseudoBlock = document.getElementById('pseudo-block');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const stepForwardBtn = document.getElementById('step-forward-btn');
            const stepBackBtn = document.getElementById('step-back-btn');
            const resetBtn = document.getElementById('reset-btn');
            const generateDataBtn = document.getElementById('generate-data-btn');
            const speedSlider = document.getElementById('speed-slider');
            const codeTabBtn = document.querySelector('.tab-btn[data-tab="code"]');
            const pseudoTabBtn = document.querySelector('.tab-btn[data-tab="pseudo"]');
            const codeContent = document.getElementById('code-content');
            const pseudoContent = document.getElementById('pseudo-content');
            const darkModeToggle = document.getElementById('darkModeToggle');
            const statusMessage = document.getElementById('status-message');
            const tabButtons = document.querySelectorAll('.tab-btn');

            // --- State Variables ---
            let currentAlgorithmKey = null;
            let currentAlgorithm = null;
            let currentData = [];
            let animationState = {
                steps: [],
                elements: [], // Main bars
                countElements: [], // Cells for count array vis
                outputElements: [], // Cells for output array vis
                currentStep: -1,
                isPlaying: false,
                timerId: null,
                speed: calculateDelay(5),
                targetValue: null, // Used for search algos
            };

            // --- Algorithm Definitions ---
            const algorithms = {
                 // ================== LINEAR SEARCH ==================
                'linear-search': {
                    name: 'Linear Search',
                    code: `<span class="code-keyword">function</span> <span class="code-function">linearSearch</span>(arr, target) {
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < arr.length; i++) {
    <span class="code-comment">// Visualize comparison</span>
    <span class="code-keyword">if</span> (arr[i] === target) {
      <span class="code-comment">// Visualize found</span>
      <span class="code-keyword">return</span> i; <span class="code-comment">// Return index if found</span>
    }
    <span class="code-comment">// Visualize element checked, not found yet</span>
  }
  <span class="code-comment">// Visualize not found after loop</span>
  <span class="code-keyword">return</span> -<span class="code-number">1</span>; <span class="code-comment">// Return -1 if not found</span>
}`,
                    pseudocode: `LinearSearch(A, value):
  for i = 0 to length(A) - 1
    // Compare A[i] with value
    if A[i] == value
      // Found
      return i
    // Checked, not found yet
  // Not found
  return -1`,
                    setup: (data) => {
                        visualizationArea.innerHTML = ''; // Clear main area
                        extraVisualizationArea.innerHTML = ''; // Clear extra area
                        if (!data || data.length === 0) {
                             visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">Cannot visualize empty array.</p>`;
                             return { steps: [], elements: [], target: null };
                        }
                        const maxValue = Math.max(...data, 1);
                        const elements = data.map((value) => {
                            const bar = document.createElement('div');
                            bar.classList.add('vis-bar');
                            bar.style.height = `${(value / maxValue) * 95}%`;
                            bar.setAttribute('data-value', value);
                            bar.title = `Value: ${value}`;
                            visualizationArea.appendChild(bar);
                            return bar;
                        });

                        let steps = [];
                        let arr = [...data];
                        const targetIndex = Math.floor(Math.random() * arr.length);
                        const target = arr[targetIndex];
                        let found = false;

                        steps.push({ type: 'start', arrayState: [...arr], target: target, message: `Starting Linear Search. Target: ${target}` });
                        for (let i = 0; i < arr.length; i++) {
                            steps.push({ type: 'compare', index: i, target: target, arrayState: [...arr], message: `Checking index ${i} (Value: ${arr[i]})` });
                            if (arr[i] === target) {
                                steps.push({ type: 'found', index: i, target: target, arrayState: [...arr], message: `Found target ${target} at index ${i}!` });
                                found = true;
                                break;
                            } else {
                                steps.push({ type: 'checked', index: i, target: target, arrayState: [...arr], message: `Index ${i} (Value: ${arr[i]}) is not the target.` });
                            }
                        }
                        if (!found) {
                            steps.push({ type: 'not-found', target: target, arrayState: [...arr], message: `Target ${target} not found in the array.` });
                        }
                        steps.push({ type: 'finish', target: target, arrayState: [...arr], found: found, message: `Search finished. Target ${target} ${found ? 'was found' : 'was not found'}.` });
                        return { steps, elements, target };
                    },
                    renderStep: (step, elements, animationState) => {
                        if (!step || !elements || elements.length === 0) return;
                        elements.forEach((bar) => {
                            // Reset common classes first
                            bar.className = 'vis-bar'; // Reset all specific classes
                            bar.style.opacity = '1';
                            bar.style.transform = 'translateY(0)'; // Reset transform
                            bar.style.borderColor = 'transparent';

                            if (step.type === 'finish') {
                                if (!bar.classList.contains('found')) {
                                     bar.classList.add('checked');
                                     bar.style.opacity = '0.6';
                                }
                            }
                        });
                        switch (step.type) {
                            case 'compare': if (elements[step.index]) elements[step.index].classList.add('comparing'); break;
                            case 'found':
                                if (elements[step.index]) elements[step.index].classList.add('found');
                                elements.forEach((bar, idx) => { if (idx !== step.index) { bar.classList.add('checked'); bar.style.opacity = '0.6'; } });
                                break;
                             case 'checked': if (elements[step.index]) { elements[step.index].classList.add('checked'); elements[step.index].style.opacity = '0.6'; } break;
                            case 'not-found': elements.forEach(bar => { bar.classList.add('checked'); bar.style.opacity = '0.6'; }); break;
                        }
                        statusMessage.textContent = step.message || '';
                    }
                },
                 // ================== BINARY SEARCH ==================
                'binary-search': {
                    name: 'Binary Search',
                    requiresSortedData: true,
                    code: `<span class="code-keyword">function</span> <span class="code-function">binarySearch</span>(sortedArr, target) {
  <span class="code-keyword">let</span> low = <span class="code-number">0</span>;
  <span class="code-keyword">let</span> high = sortedArr.length - <span class="code-number">1</span>;

  <span class="code-keyword">while</span> (low <= high) {
    <span class="code-comment">// Visualize current range [low, high]</span>
    <span class="code-keyword">const</span> mid = Math.<span class="code-function">floor</span>((low + high) / <span class="code-number">2</span>);
    <span class="code-comment">// Visualize mid element comparison</span>
    <span class="code-keyword">const</span> guess = sortedArr[mid];

    <span class="code-keyword">if</span> (guess === target) {
      <span class="code-comment">// Visualize found</span>
      <span class="code-keyword">return</span> mid; <span class="code-comment">// Found</span>
    } <span class="code-keyword">else if</span> (guess > target) {
      <span class="code-comment">// Visualize adjusting high</span>
      high = mid - <span class="code-number">1</span>; <span class="code-comment">// Target is in the lower half</span>
    } <span class="code-keyword">else</span> {
      <span class="code-comment">// Visualize adjusting low</span>
      low = mid + <span class="code-number">1</span>; <span class="code-comment">// Target is in the upper half</span>
    }
  }
  <span class="code-comment">// Visualize not found</span>
  <span class="code-keyword">return</span> -<span class="code-number">1</span>; <span class="code-comment">// Not found</span>
}`,
                    pseudocode: `BinarySearch(A, value):
  // Ensure A is sorted
  low = 0
  high = length(A) - 1

  while low <= high
    // Consider range [low, high]
    mid = floor((low + high) / 2)
    // Compare A[mid] with value
    guess = A[mid]

    if guess == value
      // Found
      return mid
    else if guess > value
      // Adjust high pointer
      high = mid - 1
    else
      // Adjust low pointer
      low = mid + 1
  // Not found
  return -1`,
                    setup: (data) => {
                        visualizationArea.innerHTML = ''; // Clear main area
                        extraVisualizationArea.innerHTML = ''; // Clear extra area
                        if (!data || data.length === 0) {
                            visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">Cannot visualize empty array.</p>`;
                            return { steps: [], elements: [], target: null };
                        }
                        const sortedData = [...data].sort((a, b) => a - b);
                        const maxValue = Math.max(...sortedData, 1);
                        const elements = sortedData.map((value) => {
                            const bar = document.createElement('div');
                            bar.classList.add('vis-bar');
                            bar.style.height = `${(value / maxValue) * 95}%`;
                            bar.setAttribute('data-value', value);
                            bar.title = `Value: ${value}`;
                            visualizationArea.appendChild(bar);
                            return bar;
                        });

                        let steps = [];
                        let arr = sortedData;
                        let target;
                        if (Math.random() > 0.3) { const targetIndex = Math.floor(Math.random() * arr.length); target = arr[targetIndex]; }
                        else { target = Math.floor(Math.random() * 120) + 5; }

                        let low = 0; let high = arr.length - 1; let found = false; let foundIndex = -1;
                        steps.push({ type: 'start', arrayState: [...arr], target: target, low: low, high: high, message: `Starting Binary Search. Target: ${target}. Range [${low}, ${high}]` });
                        while (low <= high) {
                             const mid = Math.floor((low + high) / 2); const guess = arr[mid];
                             steps.push({ type: 'check-mid', arrayState: [...arr], target: target, low: low, high: high, mid: mid, message: `Checking middle index ${mid} (Value: ${guess}). Range [${low}, ${high}]` });
                             if (guess === target) {
                                 steps.push({ type: 'found', arrayState: [...arr], target: target, low: low, high: high, mid: mid, index: mid, message: `Found target ${target} at index ${mid}!` });
                                 found = true; foundIndex = mid; break;
                             } else if (guess > target) {
                                 const newHigh = mid - 1;
                                 steps.push({ type: 'adjust-high', arrayState: [...arr], target: target, low: low, high: newHigh, mid: mid, message: `Target ${target} < ${guess}. Adjusting range to [${low}, ${newHigh}]` });
                                 high = newHigh;
                             } else {
                                 const newLow = mid + 1;
                                 steps.push({ type: 'adjust-low', arrayState: [...arr], target: target, low: newLow, high: high, mid: mid, message: `Target ${target} > ${guess}. Adjusting range to [${newLow}, ${high}]` });
                                 low = newLow;
                             }
                        }
                        if (!found) { steps.push({ type: 'not-found', arrayState: [...arr], target: target, low: low, high: high, message: `Target ${target} not found (low > high).` }); }
                        steps.push({ type: 'finish', arrayState: [...arr], target: target, found: found, index: foundIndex, message: `Search finished. Target ${target} ${found ? `found at index ${foundIndex}` : 'not found'}.` });
                        return { steps, elements, target };
                    },
                    renderStep: (step, elements, animationState) => {
                        if (!step || !elements || elements.length === 0) return;
                        elements.forEach((bar, index) => {
                            // Reset common classes first
                            bar.className = 'vis-bar'; // Reset all specific classes
                            bar.style.opacity = '1';
                            bar.style.transform = 'translateY(0)';
                            bar.style.borderColor = 'transparent';

                            if (step.type !== 'finish') {
                                if (step.low !== undefined && step.high !== undefined) {
                                    if (index >= step.low && index <= step.high) {
                                        bar.classList.add('in-range');
                                    } else {
                                        bar.classList.add('out-of-range');
                                        bar.style.opacity = '0.4';
                                    }
                                }
                            } else { // Handle final state styling
                                if (step.found && index === step.index) {
                                    bar.classList.add('found');
                                    bar.style.opacity = '1';
                                } else {
                                    bar.classList.add('out-of-range');
                                    bar.style.opacity = '0.4';
                                }
                            }
                        });

                        switch (step.type) {
                            case 'check-mid': if (elements[step.mid]) elements[step.mid].classList.add('comparing'); break;
                            case 'adjust-high': case 'adjust-low':
                                if (elements[step.mid]) { elements[step.mid].classList.add('checked'); elements[step.mid].style.opacity = '0.4'; } break;
                            case 'found':
                                if (elements[step.index]) {
                                    elements.forEach(bar => bar.classList.remove('comparing', 'in-range', 'out-of-range')); // Clean up range styles
                                    elements[step.index].classList.add('found');
                                    elements.forEach((bar, idx) => { if (idx !== step.index) { bar.classList.add('out-of-range'); bar.style.opacity = '0.4'; } });
                                } break;
                            case 'not-found':
                                elements.forEach(bar => { bar.classList.remove('comparing', 'in-range'); bar.classList.add('out-of-range'); bar.style.opacity = '0.4'; }); break;
                        }
                        statusMessage.textContent = step.message || '';
                    }
                },
                // ================== BUBBLE SORT ==================
                'bubble-sort': {
                    name: 'Bubble Sort',
                    code: `<span class="code-keyword">function</span> <span class="code-function">bubbleSort</span>(arr) {
  <span class="code-keyword">let</span> n = arr.length;
  <span class="code-keyword">let</span> swapped;
  <span class="code-keyword">do</span> {
    swapped = <span class="code-keyword">false</span>;
    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < n - <span class="code-number">1</span>; i++) {
      <span class="code-comment">// Compare adjacent elements</span>
      <span class="code-keyword">if</span> (arr[i] > arr[i + <span class="code-number">1</span>]) {
        <span class="code-comment">// Swap them</span>
        [arr[i], arr[i + <span class="code-number">1</span>]] = [arr[i + <span class="code-number">1</span>], arr[i]];
        swapped = <span class="code-keyword">true</span>;
        <span class="code-comment">// Visualize swap</span>
      }
      <span class="code-comment">// Visualize comparison</span>
    }
    <span class="code-comment">// Mark last element as sorted for this pass</span>
    n--;
  } <span class="code-keyword">while</span> (swapped);
  <span class="code-comment">// Mark all as sorted</span>
  <span class="code-keyword">return</span> arr;
}`,
                    pseudocode: `BubbleSort(A):
  n = length(A)
  repeat
    swapped = false
    for i = 0 to n - 2
      // Compare adjacent elements
      if A[i] > A[i + 1]
        // Swap elements
        swap(A[i], A[i + 1])
        swapped = true
        // Visualize swap
      // Visualize comparison
    // Mark A[n-1] as sorted for this pass
    n = n - 1
  until not swapped
  // Mark all elements as sorted`,
                    setup: (data) => {
                        visualizationArea.innerHTML = ''; // Clear main area
                        extraVisualizationArea.innerHTML = ''; // Clear extra area
                         if (!data || data.length === 0) {
                             visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">Cannot visualize empty array.</p>`;
                             return { steps: [], elements: [] };
                        }
                        const maxValue = Math.max(...data, 1);
                        const elements = data.map((value) => {
                            const bar = document.createElement('div');
                            bar.classList.add('vis-bar');
                            bar.style.height = `${(value / maxValue) * 95}%`;
                            bar.setAttribute('data-value', value);
                            bar.title = `Value: ${value}`;
                            visualizationArea.appendChild(bar);
                            return bar;
                        });

                        let steps = []; let arr = [...data]; let n = arr.length; let localSwapped; let sortedBoundary = n;
                        steps.push({ type: 'start', arrayState: [...arr], message: 'Starting Bubble Sort' });
                        do {
                            localSwapped = false;
                            for (let i = 0; i < sortedBoundary - 1; i++) {
                                steps.push({ type: 'compare', indices: [i, i + 1], arrayState: [...arr], sortedBoundary: sortedBoundary, message: `Comparing ${arr[i]} and ${arr[i+1]}` });
                                if (arr[i] > arr[i + 1]) {
                                    [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
                                    localSwapped = true;
                                    steps.push({ type: 'swap', indices: [i, i + 1], arrayState: [...arr], sortedBoundary: sortedBoundary, message: `Swapping ${arr[i+1]} and ${arr[i]}` });
                                }
                            }
                             if (sortedBoundary > 0) { steps.push({ type: 'mark-sorted-pass', index: sortedBoundary - 1, arrayState: [...arr], sortedBoundary: sortedBoundary -1, message: `Element ${arr[sortedBoundary - 1]} is sorted for this pass` }); }
                            sortedBoundary--;
                        } while (localSwapped && sortedBoundary > 0);
                        steps.push({ type: 'finish', arrayState: [...arr], message: 'Array is sorted!' });
                        return { steps, elements };
                    },
                    renderStep: (step, elements) => {
                        if (!step || !elements || elements.length === 0) return;
                        const maxValue = Math.max(...step.arrayState, 1);
                        elements.forEach((bar, index) => {
                            // Reset common classes first
                            bar.className = 'vis-bar'; // Reset all specific classes
                            bar.style.opacity = '1';
                            bar.style.transform = 'translateY(0)';
                            bar.style.borderColor = 'transparent';

                            // Update height
                            bar.style.height = `${(step.arrayState[index] / maxValue) * 95}%`;
                            bar.title = `Value: ${step.arrayState[index]}`;

                             // Apply sorted-pass style for elements beyond the current boundary
                            if (step.sortedBoundary !== undefined && index >= step.sortedBoundary && step.type !== 'finish') {
                                bar.classList.add('sorted-pass');
                            }
                        });

                        switch (step.type) {
                            case 'compare':
                                if (elements[step.indices[0]]) elements[step.indices[0]].classList.add('comparing');
                                if (elements[step.indices[1]]) elements[step.indices[1]].classList.add('comparing'); break;
                            case 'swap':
                                if (elements[step.indices[0]]) elements[step.indices[0]].classList.add('swapping');
                                if (elements[step.indices[1]]) elements[step.indices[1]].classList.add('swapping'); break;
                            case 'mark-sorted-pass':
                                // Style is applied in the initial loop based on sortedBoundary
                                break;
                            case 'finish':
                                elements.forEach(bar => { bar.className = 'vis-bar sorted-final'; }); // Set final state
                                break;
                        }
                        statusMessage.textContent = step.message || '';
                    }
                },
                // ================== SELECTION SORT ==================
                'selection-sort': {
                    name: 'Selection Sort',
                    code: `<span class="code-keyword">function</span> <span class="code-function">selectionSort</span>(arr) {
  <span class="code-keyword">const</span> n = arr.length;
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < n - <span class="code-number">1</span>; i++) {
    <span class="code-comment">// Assume the minimum is the first element of the unsorted part</span>
    <span class="code-keyword">let</span> minIndex = i;
    <span class="code-comment">// Visualize starting search for minimum in arr[i..n-1]</span>

    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> j = i + <span class="code-number">1</span>; j < n; j++) {
      <span class="code-comment">// Visualize comparing j with current minimum</span>
      <span class="code-keyword">if</span> (arr[j] < arr[minIndex]) {
        <span class="code-comment">// Visualize new minimum found</span>
        minIndex = j;
      }
    }

    <span class="code-comment">// Swap the found minimum element with the first element of the unsorted part</span>
    <span class="code-keyword">if</span> (minIndex !== i) {
      <span class="code-comment">// Visualize swap</span>
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
    <span class="code-comment">// Visualize element at index i is now sorted</span>
  }
  <span class="code-comment">// Visualize final element is sorted</span>
  <span class="code-keyword">return</span> arr;
}`,
                    pseudocode: `SelectionSort(A):
  n = length(A)
  for i = 0 to n - 2
    // Find the index of the minimum element in A[i..n-1]
    minIndex = i
    // Visualize starting search for min in A[i..n-1]
    for j = i + 1 to n - 1
      // Compare A[j] with current minimum A[minIndex]
      if A[j] < A[minIndex]
        // Found new minimum
        minIndex = j
        // Visualize new minimum

    // Swap A[i] with A[minIndex] if they are different
    if minIndex != i
      // Visualize swap
      swap(A[i], A[minIndex])

    // Mark A[i] as sorted
  // Mark A[n-1] as sorted`,
                    setup: (data) => {
                        visualizationArea.innerHTML = ''; // Clear main area
                        extraVisualizationArea.innerHTML = ''; // Clear extra area
                        if (!data || data.length === 0) {
                            visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">Cannot visualize empty array.</p>`;
                            return { steps: [], elements: [] };
                        }
                        const maxValue = Math.max(...data, 1);
                        const elements = data.map((value) => {
                            const bar = document.createElement('div');
                            bar.classList.add('vis-bar');
                            bar.style.height = `${(value / maxValue) * 95}%`;
                            bar.setAttribute('data-value', value);
                            bar.title = `Value: ${value}`;
                            visualizationArea.appendChild(bar);
                            return bar;
                        });

                        let steps = [];
                        let arr = [...data];
                        const n = arr.length;

                        steps.push({ type: 'start', arrayState: [...arr], message: 'Starting Selection Sort' });
                        for (let i = 0; i < n - 1; i++) {
                            let minIndex = i;
                            steps.push({ type: 'find-min-start', arrayState: [...arr], outerIndex: i, minIndex: minIndex, message: `Finding minimum for index ${i}` });
                            for (let j = i + 1; j < n; j++) {
                                steps.push({ type: 'compare-inner', arrayState: [...arr], outerIndex: i, minIndex: minIndex, compareIndex: j, message: `Comparing index ${j} (${arr[j]}) with current min (${arr[minIndex]})` });
                                if (arr[j] < arr[minIndex]) {
                                    const oldMinIndex = minIndex;
                                    minIndex = j;
                                    steps.push({ type: 'new-min', arrayState: [...arr], outerIndex: i, minIndex: minIndex, oldMinIndex: oldMinIndex, compareIndex: j, message: `New minimum found at index ${j} (${arr[j]})` });
                                }
                            }
                            if (minIndex !== i) {
                                steps.push({ type: 'swap', arrayState: [...arr], outerIndex: i, swapIndices: [i, minIndex], message: `Swapping minimum (${arr[minIndex]}) with element at index ${i} (${arr[i]})` });
                                [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
                                steps.push({ type: 'after-swap', arrayState: [...arr], outerIndex: i, swapIndices: [i, minIndex], message: `Swap complete. Minimum now at index ${i}.` });
                            } else {
                                steps.push({ type: 'no-swap', arrayState: [...arr], outerIndex: i, message: `Element at index ${i} (${arr[i]}) is already the minimum. No swap needed.` });
                            }
                            steps.push({ type: 'mark-sorted', arrayState: [...arr], index: i, message: `Element at index ${i} is now sorted.` });
                        }
                         if (n > 0) { steps.push({ type: 'mark-sorted', arrayState: [...arr], index: n - 1, message: `Element at index ${n-1} is now sorted.` }); }
                        steps.push({ type: 'finish', arrayState: [...arr], message: 'Array is sorted!' });
                        return { steps, elements };
                    },
                    renderStep: (step, elements) => {
                        if (!step || !elements || elements.length === 0) return;
                        const maxValue = Math.max(...step.arrayState, 1);

                        elements.forEach((bar, index) => {
                            // Reset common classes first
                             bar.className = 'vis-bar'; // Reset all specific classes
                            bar.style.opacity = '1';
                            bar.style.transform = 'translateY(0)';
                            bar.style.borderColor = 'transparent';

                            bar.style.height = `${(step.arrayState[index] / maxValue) * 95}%`;
                            bar.title = `Value: ${step.arrayState[index]}`;

                            // Apply sorted style up to the outer loop index for relevant steps
                            if (step.outerIndex !== undefined && index < step.outerIndex && (step.type !== 'finish')) {
                                bar.classList.add('sorted-final');
                            }
                        });

                        switch (step.type) {
                            case 'find-min-start':
                                if (elements[step.outerIndex]) elements[step.outerIndex].classList.add('current-outer');
                                if (elements[step.minIndex]) elements[step.minIndex].classList.add('minimum');
                                break;
                            case 'compare-inner':
                                if (elements[step.outerIndex]) elements[step.outerIndex].classList.add('current-outer');
                                if (elements[step.minIndex]) elements[step.minIndex].classList.add('minimum');
                                if (elements[step.compareIndex]) elements[step.compareIndex].classList.add('comparing');
                                break;
                            case 'new-min':
                                if (elements[step.outerIndex]) elements[step.outerIndex].classList.add('current-outer');
                                if (elements[step.minIndex]) elements[step.minIndex].classList.add('minimum');
                                // Remove minimum from old min index if it exists
                                if (step.oldMinIndex !== undefined && elements[step.oldMinIndex]) {
                                     elements[step.oldMinIndex].classList.remove('minimum');
                                }
                                break;
                            case 'swap': case 'after-swap':
                                if (elements[step.swapIndices[0]]) elements[step.swapIndices[0]].classList.add('swapping');
                                if (elements[step.swapIndices[1]]) elements[step.swapIndices[1]].classList.add('swapping');
                                break;
                             case 'no-swap':
                                if (elements[step.outerIndex]) { elements[step.outerIndex].classList.add('current-outer'); elements[step.outerIndex].classList.add('minimum'); }
                                break;
                            case 'mark-sorted':
                                if (elements[step.index]) { elements[step.index].className = 'vis-bar sorted-final'; } // Set final state for this index
                                // Ensure previous elements are also marked sorted
                                for(let k=0; k < step.index; k++) { if(elements[k]) elements[k].classList.add('sorted-final'); }
                                break;
                            case 'finish':
                                elements.forEach(bar => { bar.className = 'vis-bar sorted-final'; }); // Set final state for all
                                break;
                        }
                        statusMessage.textContent = step.message || '';
                    }
                },
                // ================== INSERTION SORT ==================
                'insertion-sort': {
                    name: 'Insertion Sort',
                    code: `<span class="code-keyword">function</span> <span class="code-function">insertionSort</span>(arr) {
  <span class="code-keyword">const</span> n = arr.length;
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">1</span>; i < n; i++) {
    <span class="code-comment">// Select the element to be inserted</span>
    <span class="code-keyword">let</span> current = arr[i];
    <span class="code-keyword">let</span> j = i - <span class="code-number">1</span>;
    <span class="code-comment">// Visualize selecting 'current'</span>

    <span class="code-comment">// Shift elements of the sorted segment forward</span>
    <span class="code-keyword">while</span> (j >= <span class="code-number">0</span> && arr[j] > current) {
      <span class="code-comment">// Visualize comparison and shift</span>
      arr[j + <span class="code-number">1</span>] = arr[j];
      j--;
    }
    <span class="code-comment">// Insert the current element into its correct position</span>
    arr[j + <span class="code-number">1</span>] = current;
    <span class="code-comment">// Visualize insertion</span>
  }
  <span class="code-comment">// Visualize array is sorted</span>
  <span class="code-keyword">return</span> arr;
}`,
                    pseudocode: `InsertionSort(A):
  n = length(A)
  for i = 1 to n - 1
    key = A[i]  // Element to insert
    j = i - 1   // Index in the sorted subarray
    // Visualize selecting key

    // Move elements of A[0..i-1] that are greater than key,
    // to one position ahead of their current position
    while j >= 0 and A[j] > key
      // Visualize comparison and shift
      A[j + 1] = A[j]
      j = j - 1

    // Place key at after the element just smaller than it.
    A[j + 1] = key
    // Visualize insertion
  // Visualize array sorted`,
                    setup: (data) => {
                        visualizationArea.innerHTML = ''; // Clear main area
                        extraVisualizationArea.innerHTML = ''; // Clear extra area
                        if (!data || data.length === 0) {
                            visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">Cannot visualize empty array.</p>`;
                            return { steps: [], elements: [] };
                        }
                        const maxValue = Math.max(...data, 1);
                        const elements = data.map((value) => {
                            const bar = document.createElement('div');
                            bar.classList.add('vis-bar');
                            bar.style.height = `${(value / maxValue) * 95}%`;
                            bar.setAttribute('data-value', value);
                            bar.title = `Value: ${value}`;
                            visualizationArea.appendChild(bar);
                            return bar;
                        });

                        let steps = [];
                        let arr = [...data];
                        const n = arr.length;

                         steps.push({ type: 'start', arrayState: [...arr], sortedUntil: 0, message: 'Starting Insertion Sort. First element is sorted.' });

                        for (let i = 1; i < n; i++) {
                            let key = arr[i];
                            let j = i - 1;

                            steps.push({ type: 'select-key', arrayState: [...arr], keyIndex: i, sortedUntil: i - 1, message: `Selecting element ${key} at index ${i} to insert.` });

                            let shiftedIndices = [];
                            let comparisonIndex = -1;
                            let didShift = false;
                            let tempArrState = [...arr]; // Temp state during shifting

                            while (j >= 0 && tempArrState[j] > key) {
                                didShift = true;
                                comparisonIndex = j;
                                steps.push({ type: 'compare-shift', arrayState: [...tempArrState], keyIndex: i, keyVal: key, compareIndex: j, sortedUntil: i - 1, shifting: true, message: `Comparing key ${key} with ${tempArrState[j]}. Shifting ${tempArrState[j]} right.` });
                                tempArrState[j + 1] = tempArrState[j]; // Shift in temp array
                                shiftedIndices.push(j + 1);
                                j--;
                                steps.push({ type: 'after-shift', arrayState: [...tempArrState], keyIndex: i, keyVal: key, shiftedFrom: j + 1, shiftedTo: j + 2, sortedUntil: i - 1, message: `Shifted element to index ${j + 2}.` });
                            }

                            if (j >= 0) {
                                comparisonIndex = j;
                                steps.push({ type: 'compare-no-shift', arrayState: [...tempArrState], keyIndex: i, keyVal: key, compareIndex: j, sortedUntil: i - 1, message: `Comparing key ${key} with ${tempArrState[j]}. No shift needed.` });
                            }

                            const insertPos = j + 1;
                            if (insertPos !== i || didShift) { // Check if insertion actually happened or shifts occurred
                                tempArrState[insertPos] = key; // Insert key into temp array
                                steps.push({ type: 'insert', arrayState: [...tempArrState], keyIndex: i, keyVal: key, insertIndex: insertPos, sortedUntil: i, message: `Inserting key ${key} at index ${insertPos}.` });
                                arr = [...tempArrState]; // Update main array only after insertion is done for the step
                            } else {
                                steps.push({ type: 'no-insert-needed', arrayState: [...arr], keyIndex: i, sortedUntil: i, message: `Element ${key} already in sorted position.` });
                            }

                             steps.push({ type: 'mark-sorted', arrayState: [...arr], sortedUntil: i, message: `Elements up to index ${i} are now sorted.` });
                        }

                        steps.push({ type: 'finish', arrayState: [...arr], message: 'Array is sorted!' });
                        return { steps, elements };
                    },
                    renderStep: (step, elements) => {
                        if (!step || !elements || elements.length === 0) return;
                        const maxValue = Math.max(...step.arrayState, 1);

                        elements.forEach((bar, index) => {
                            // Reset common classes first
                             bar.className = 'vis-bar'; // Reset all specific classes
                            bar.style.opacity = '1';
                            bar.style.transform = 'translateY(0)'; // Reset lift
                            bar.style.borderColor = 'transparent';

                            bar.style.height = `${(step.arrayState[index] / maxValue) * 95}%`;
                            bar.title = `Value: ${step.arrayState[index]}`;

                            if (step.sortedUntil !== undefined && index <= step.sortedUntil && (step.type !== 'finish')) {
                                bar.classList.add('sorted-final');
                            }
                        });

                        switch (step.type) {
                            case 'select-key':
                                if (elements[step.keyIndex]) elements[step.keyIndex].classList.add('current-insertion');
                                break;
                            case 'compare-shift':
                            case 'compare-no-shift':
                                if (elements[step.keyIndex]) elements[step.keyIndex].classList.add('current-insertion');
                                if (elements[step.compareIndex]) elements[step.compareIndex].classList.add('comparing');
                                if (step.shifting && elements[step.compareIndex]) {
                                    elements[step.compareIndex].classList.add('shifting');
                                }
                                break;
                            case 'after-shift':
                                if (elements[step.keyIndex]) elements[step.keyIndex].classList.add('current-insertion');
                                if (elements[step.shiftedTo]) {
                                    elements[step.shiftedTo].classList.add('shifting');
                                }
                                break;
                            case 'insert':
                            case 'no-insert-needed':
                                const finalIndex = step.insertIndex !== undefined ? step.insertIndex : step.keyIndex;
                                if (elements[finalIndex]) {
                                    elements[finalIndex].className = 'vis-bar sorted-final'; // Ensure only sorted-final is applied
                                }
                                break;
                            case 'mark-sorted':
                                // Styling applied in the initial loop based on sortedUntil
                                break;
                            case 'finish':
                                elements.forEach(bar => { bar.className = 'vis-bar sorted-final'; }); // Set final state
                                break;
                        }
                        statusMessage.textContent = step.message || '';
                    }
                },
                 // ================== QUICK SORT ==================
                'quick-sort': {
                    name: 'Quick Sort (Lomuto)',
                    code: `<span class="code-keyword">function</span> <span class="code-function">quickSort</span>(arr, low, high) {
  <span class="code-keyword">if</span> (low < high) {
    <span class="code-comment">// pi is partitioning index, arr[pi] is now at right place</span>
    <span class="code-keyword">let</span> pi = <span class="code-function">partition</span>(arr, low, high);
    <span class="code-comment">// Visualize pivot in final place</span>

    <span class="code-comment">// Separately sort elements before partition and after partition</span>
    <span class="code-function">quickSort</span>(arr, low, pi - <span class="code-number">1</span>); <span class="code-comment">// Visualize recursive call left</span>
    <span class="code-function">quickSort</span>(arr, pi + <span class="code-number">1</span>, high); <span class="code-comment">// Visualize recursive call right</span>
  } <span class="code-keyword">else</span> {
      <span class="code-comment">// Visualize base case (partition of size 0 or 1 is sorted)</span>
  }
}

<span class="code-comment">// Lomuto partition scheme</span>
<span class="code-keyword">function</span> <span class="code-function">partition</span>(arr, low, high) {
  <span class="code-comment">// Select the last element as pivot</span>
  <span class="code-keyword">let</span> pivot = arr[high];
  <span class="code-comment">// Visualize pivot selection</span>

  <span class="code-comment">// Index of smaller element</span>
  <span class="code-keyword">let</span> i = low - <span class="code-number">1</span>;
  <span class="code-comment">// Visualize pointers i and j start</span>

  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> j = low; j < high; j++) {
    <span class="code-comment">// Visualize comparison of j with pivot</span>
    <span class="code-keyword">if</span> (arr[j] < pivot) {
      i++; <span class="code-comment">// Increment index of smaller element</span>
      <span class="code-comment">// Visualize swap of i and j</span>
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  <span class="code-comment">// Swap pivot (arr[high]) with the element at i + 1</span>
  <span class="code-comment">// Visualize final pivot swap</span>
  [arr[i + <span class="code-number">1</span>], arr[high]] = [arr[high], arr[i + <span class="code-number">1</span>]];
  <span class="code-keyword">return</span> i + <span class="code-number">1</span>; <span class="code-comment">// Return the partition index</span>
}`,
                    pseudocode: `QuickSort(A, low, high):
  if low < high:
    // Partition the array
    pi = Partition(A, low, high)
    // Mark pivot A[pi] as sorted for this partition

    // Recursively sort elements before and after partition
    QuickSort(A, low, pi - 1)
    QuickSort(A, pi + 1, high)
  else:
    // Base case: Mark element(s) in range [low, high] as sorted

Partition(A, low, high):
  pivot = A[high] // Choose last element as pivot
  // Visualize pivot selection

  i = low - 1 // Index of smaller element
  // Visualize pointers i and j start

  for j = low to high - 1:
    // Compare A[j] with pivot
    if A[j] < pivot:
      i = i + 1
      // Swap A[i] and A[j]
      swap(A[i], A[j])
      // Visualize swap

  // Swap A[i+1] and A[high] (pivot)
  swap(A[i + 1], A[high])
  // Visualize final pivot swap
  return (i + 1) // Return partition index`,
                    setup: (data) => {
                        visualizationArea.innerHTML = ''; // Clear main area
                        extraVisualizationArea.innerHTML = ''; // Clear extra area
                        if (!data || data.length === 0) {
                            visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">Cannot visualize empty array.</p>`;
                            return { steps: [], elements: [] };
                        }
                        const maxValue = Math.max(...data, 1);
                        const elements = data.map((value) => {
                            const bar = document.createElement('div');
                            bar.classList.add('vis-bar');
                            bar.style.height = `${(value / maxValue) * 95}%`;
                            bar.setAttribute('data-value', value);
                            bar.title = `Value: ${value}`;
                            visualizationArea.appendChild(bar);
                            return bar;
                        });

                        let steps = [];
                        let arr = [...data];
                        let sortedStatus = new Array(arr.length).fill(false); // Track final sorted elements

                        function partition(low, high) {
                            let pivot = arr[high];
                            let i = low - 1;
                            steps.push({ type: 'select-pivot', arrayState: [...arr], sortedStatus: [...sortedStatus], low: low, high: high, pivotIndex: high, i: i, message: `Partitioning [${low}, ${high}]. Pivot: ${pivot} (index ${high})` });
                            for (let j = low; j < high; j++) {
                                steps.push({ type: 'compare-partition', arrayState: [...arr], sortedStatus: [...sortedStatus], low: low, high: high, pivotIndex: high, i: i, j: j, message: `Comparing element ${arr[j]} (j=${j}) with pivot ${pivot}` });
                                if (arr[j] < pivot) {
                                    i++;
                                    steps.push({ type: 'swap-partition', arrayState: [...arr], sortedStatus: [...sortedStatus], low: low, high: high, pivotIndex: high, i: i, j: j, swapIndices: [i, j], message: `Element ${arr[j]} < pivot ${pivot}. Swapping A[${i}] (${arr[i]}) and A[${j}] (${arr[j]})` });
                                    [arr[i], arr[j]] = [arr[j], arr[i]];
                                    steps.push({ type: 'after-swap-partition', arrayState: [...arr], sortedStatus: [...sortedStatus], low: low, high: high, pivotIndex: high, i: i, j: j, swapIndices: [i, j], message: `Swap complete.` });
                                }
                            }
                            const pivotFinalIndex = i + 1;
                            steps.push({ type: 'swap-pivot-final', arrayState: [...arr], sortedStatus: [...sortedStatus], low: low, high: high, pivotIndex: high, i: i, swapIndices: [pivotFinalIndex, high], message: `Swapping pivot ${arr[high]} with element at i+1 (${arr[pivotFinalIndex]})` });
                            [arr[pivotFinalIndex], arr[high]] = [arr[high], arr[pivotFinalIndex]];
                            sortedStatus[pivotFinalIndex] = true; // Mark pivot as sorted
                            steps.push({ type: 'partition-done', arrayState: [...arr], sortedStatus: [...sortedStatus], low: low, high: high, pivotFinalIndex: pivotFinalIndex, message: `Pivot ${arr[pivotFinalIndex]} is in final position ${pivotFinalIndex}. Partition complete for [${low}, ${high}].` });
                            return pivotFinalIndex;
                        }

                        function quickSortRecursive(low, high) {
                            if (low < high) {
                                let pi = partition(low, high);
                                steps.push({ type: 'recursive-call', arrayState: [...arr], sortedStatus: [...sortedStatus], low: low, high: pi - 1, pivotFinalIndex: pi, message: `Recursive call for left subarray [${low}, ${pi - 1}]` });
                                quickSortRecursive(low, pi - 1);
                                steps.push({ type: 'recursive-call', arrayState: [...arr], sortedStatus: [...sortedStatus], low: pi + 1, high: high, pivotFinalIndex: pi, message: `Recursive call for right subarray [${pi + 1}, ${high}]` });
                                quickSortRecursive(pi + 1, high);
                            } else if (low >= 0 && low < arr.length && low === high) {
                                // Base case for single element partition
                                sortedStatus[low] = true;
                                steps.push({ type: 'base-case', arrayState: [...arr], sortedStatus: [...sortedStatus], low: low, high: high, message: `Base case: Element at index ${low} is sorted.` });
                            } else if (low > high) {
                                // Base case for empty partition
                                steps.push({ type: 'base-case', arrayState: [...arr], sortedStatus: [...sortedStatus], low: low, high: high, message: `Base case: Range [${low}, ${high}] is empty/sorted.` });
                            }
                        }

                        steps.push({ type: 'start', arrayState: [...arr], sortedStatus: [...sortedStatus], message: 'Starting Quick Sort' });
                        quickSortRecursive(0, arr.length - 1);
                        steps.push({ type: 'finish', arrayState: [...arr], sortedStatus: [...sortedStatus], message: 'Array is sorted!' });

                        return { steps, elements };
                    },
                    renderStep: (step, elements) => {
                        if (!step || !elements || elements.length === 0) return;
                        const maxValue = Math.max(...step.arrayState, 1);

                        elements.forEach((bar, index) => {
                            // Reset common classes first
                            bar.className = 'vis-bar'; // Reset all specific classes
                            bar.style.opacity = '1';
                            bar.style.transform = 'translateY(0)';
                            bar.style.borderColor = 'transparent';

                            // Apply final sorted style if marked in the step's status array
                            if (step.sortedStatus && step.sortedStatus[index]) {
                                bar.classList.add('sorted-final');
                            }

                            bar.style.height = `${(step.arrayState[index] / maxValue) * 95}%`;
                            bar.title = `Value: ${step.arrayState[index]}`;

                             if (step.low !== undefined && step.high !== undefined && step.type !== 'finish' && !bar.classList.contains('sorted-final')) {
                                if (index < step.low || index > step.high) {
                                     bar.classList.add('outside-partition');
                                     bar.style.opacity = '0.4';
                                } else {
                                    bar.classList.add('partition-range');
                                }
                            }
                        });

                        switch (step.type) {
                            case 'select-pivot':
                                if (elements[step.pivotIndex]) elements[step.pivotIndex].classList.add('pivot');
                                break;
                            case 'compare-partition':
                                if (elements[step.pivotIndex]) elements[step.pivotIndex].classList.add('pivot');
                                if (step.i >= 0 && elements[step.i]) elements[step.i].classList.add('partition-i');
                                if (elements[step.j]) {
                                    elements[step.j].classList.add('partition-j');
                                    elements[step.j].classList.add('comparing');
                                }
                                break;
                            case 'swap-partition':
                            case 'after-swap-partition':
                                if (elements[step.pivotIndex]) elements[step.pivotIndex].classList.add('pivot');
                                if (step.i >= 0 && elements[step.i]) elements[step.i].classList.add('partition-i');
                                if (elements[step.j]) elements[step.j].classList.add('partition-j');
                                if (elements[step.swapIndices[0]]) elements[step.swapIndices[0]].classList.add('swapping');
                                if (elements[step.swapIndices[1]]) elements[step.swapIndices[1]].classList.add('swapping');
                                break;
                             case 'swap-pivot-final':
                                if (elements[step.swapIndices[0]]) elements[step.swapIndices[0]].classList.add('swapping');
                                if (elements[step.swapIndices[1]]) {
                                    elements[step.swapIndices[1]].classList.add('swapping');
                                    elements[step.swapIndices[1]].classList.add('pivot');
                                }
                                break;
                            case 'partition-done':
                                // Pivot marked as sorted-final in the initial loop based on sortedStatus
                                if (elements[step.pivotFinalIndex]) {
                                    elements[step.pivotFinalIndex].classList.remove('pivot'); // Remove pivot border
                                }
                                break;
                            case 'recursive-call':
                                // Styling handled by range and sortedStatus
                                break;
                             case 'base-case':
                                // Styling handled by range and sortedStatus
                                break;
                            case 'finish':
                                elements.forEach(bar => { bar.className = 'vis-bar sorted-final'; bar.style.opacity = '1'; }); // Set final state
                                break;
                        }
                        statusMessage.textContent = step.message || '';
                    }
                },
                 // ================== MERGE SORT ==================
                'merge-sort': {
                    name: 'Merge Sort',
                    code: `<span class="code-keyword">function</span> <span class="code-function">mergeSort</span>(arr, l, r) {
  <span class="code-keyword">if</span> (l >= r) {
    <span class="code-keyword">return</span>; <span class="code-comment">// Base case: array of size 0 or 1 is sorted</span>
  }
  <span class="code-keyword">const</span> m = l + Math.<span class="code-function">floor</span>((r - l) / <span class="code-number">2</span>);
  <span class="code-comment">// Visualize recursive call left</span>
  <span class="code-function">mergeSort</span>(arr, l, m);
  <span class="code-comment">// Visualize recursive call right</span>
  <span class="code-function">mergeSort</span>(arr, m + <span class="code-number">1</span>, r);
  <span class="code-comment">// Visualize merge operation</span>
  <span class="code-function">merge</span>(arr, l, m, r);
}

<span class="code-keyword">function</span> <span class="code-function">merge</span>(arr, l, m, r) {
  <span class="code-keyword">let</span> n1 = m - l + <span class="code-number">1</span>;
  <span class="code-keyword">let</span> n2 = r - m;

  <span class="code-comment">// Create temporary arrays</span>
  <span class="code-keyword">let</span> L = <span class="code-keyword">new</span> <span class="code-function">Array</span>(n1);
  <span class="code-keyword">let</span> R = <span class="code-keyword">new</span> <span class="code-function">Array</span>(n2);

  <span class="code-comment">// Copy data to temp arrays L[] and R[]</span>
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < n1; i++) L[i] = arr[l + i];
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> j = <span class="code-number">0</span>; j < n2; j++) R[j] = arr[m + <span class="code-number">1</span> + j];
  <span class="code-comment">// Visualize subarrays copied</span>

  <span class="code-comment">// Merge the temp arrays back into arr[l..r]</span>
  <span class="code-keyword">let</span> i = <span class="code-number">0</span>; <span class="code-comment">// Initial index of first subarray</span>
  <span class="code-keyword">let</span> j = <span class="code-number">0</span>; <span class="code-comment">// Initial index of second subarray</span>
  <span class="code-keyword">let</span> k = l; <span class="code-comment">// Initial index of merged subarray</span>

  <span class="code-keyword">while</span> (i < n1 && j < n2) {
    <span class="code-comment">// Visualize comparison</span>
    <span class="code-keyword">if</span> (L[i] <= R[j]) {
      <span class="code-comment">// Visualize placing L[i]</span>
      arr[k] = L[i];
      i++;
    } <span class="code-keyword">else</span> {
      <span class="code-comment">// Visualize placing R[j]</span>
      arr[k] = R[j];
      j++;
    }
    k++;
  }

  <span class="code-comment">// Copy the remaining elements of L[], if any</span>
  <span class="code-keyword">while</span> (i < n1) {
    <span class="code-comment">// Visualize placing remaining L[i]</span>
    arr[k] = L[i];
    i++;
    k++;
  }

  <span class="code-comment">// Copy the remaining elements of R[], if any</span>
  <span class="code-keyword">while</span> (j < n2) {
    <span class="code-comment">// Visualize placing remaining R[j]</span>
    arr[k] = R[j];
    j++;
    k++;
  }
  <span class="code-comment">// Visualize merge complete for this range</span>
}`,
                    pseudocode: `MergeSort(A, l, r):
  if l >= r:
    return // Base case

  m = floor(l + (r - l) / 2)
  // Visualize recursive call left
  MergeSort(A, l, m)
  // Visualize recursive call right
  MergeSort(A, m + 1, r)
  // Visualize merge operation
  Merge(A, l, m, r)

Merge(A, l, m, r):
  n1 = m - l + 1
  n2 = r - m

  // Create temp arrays L and R
  L = A[l..m]
  R = A[m+1..r]
  // Visualize subarrays copied

  i = 0 // index for L
  j = 0 // index for R
  k = l // index for A

  // Merge L and R back into A[l..r]
  while i < n1 and j < n2:
    // Compare L[i] and R[j]
    if L[i] <= R[j]:
      // Place L[i] into A[k]
      A[k] = L[i]
      i = i + 1
    else:
      // Place R[j] into A[k]
      A[k] = R[j]
      j = j + 1
    k = k + 1

  // Copy remaining elements of L
  while i < n1:
    A[k] = L[i]
    i = i + 1
    k = k + 1

  // Copy remaining elements of R
  while j < n2:
    A[k] = R[j]
    j = j + 1
    k = k + 1
  // Visualize merge complete`,
                    setup: (data) => {
                        visualizationArea.innerHTML = ''; // Clear main area
                        extraVisualizationArea.innerHTML = ''; // Clear extra area
                        if (!data || data.length === 0) {
                            visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">Cannot visualize empty array.</p>`;
                            return { steps: [], elements: [] };
                        }
                        const maxValue = Math.max(...data, 1);
                        const elements = data.map((value) => {
                            const bar = document.createElement('div');
                            bar.classList.add('vis-bar');
                            bar.style.height = `${(value / maxValue) * 95}%`;
                            bar.setAttribute('data-value', value);
                            bar.title = `Value: ${value}`;
                            visualizationArea.appendChild(bar);
                            return bar;
                        });

                        let steps = [];
                        let arr = [...data]; // Work on a copy
                        let sortedStatus = new Array(arr.length).fill(false); // Track final sorted elements

                        function merge(l, m, r) {
                            let n1 = m - l + 1;
                            let n2 = r - m;
                            let L = new Array(n1);
                            let R = new Array(n2);
                            let tempArrStateBeforeMerge = [...arr]; // Capture state before merge modifications

                            steps.push({ type: 'merge-start', arrayState: [...tempArrStateBeforeMerge], sortedStatus: [...sortedStatus], low: l, mid: m, high: r, message: `Merging subarrays [${l}..${m}] and [${m+1}..${r}]` });

                            for (let i = 0; i < n1; i++) L[i] = arr[l + i];
                            for (let j = 0; j < n2; j++) R[j] = arr[m + 1 + j];

                            let i = 0, j = 0, k = l;
                            let tempArrStateDuringMerge = [...tempArrStateBeforeMerge]; // Array state during merge placement

                            while (i < n1 && j < n2) {
                                steps.push({ type: 'merge-compare', arrayState: [...tempArrStateDuringMerge], sortedStatus: [...sortedStatus], low: l, mid: m, high: r, leftIndex: l + i, rightIndex: m + 1 + j, k: k, leftVal: L[i], rightVal: R[j], message: `Comparing Left (${L[i]}) and Right (${R[j]})` });
                                if (L[i] <= R[j]) {
                                    tempArrStateDuringMerge[k] = L[i];
                                    steps.push({ type: 'merge-place', arrayState: [...tempArrStateDuringMerge], sortedStatus: [...sortedStatus], low: l, mid: m, high: r, sourceIndex: l + i, targetIndex: k, value: L[i], fromLeft: true, message: `Placing ${L[i]} from left into index ${k}` });
                                    i++;
                                } else {
                                    tempArrStateDuringMerge[k] = R[j];
                                    steps.push({ type: 'merge-place', arrayState: [...tempArrStateDuringMerge], sortedStatus: [...sortedStatus], low: l, mid: m, high: r, sourceIndex: m + 1 + j, targetIndex: k, value: R[j], fromLeft: false, message: `Placing ${R[j]} from right into index ${k}` });
                                    j++;
                                }
                                k++;
                            }
                            while (i < n1) {
                                tempArrStateDuringMerge[k] = L[i];
                                steps.push({ type: 'merge-place-remaining', arrayState: [...tempArrStateDuringMerge], sortedStatus: [...sortedStatus], low: l, mid: m, high: r, sourceIndex: l + i, targetIndex: k, value: L[i], fromLeft: true, message: `Placing remaining ${L[i]} from left into index ${k}` });
                                i++; k++;
                            }
                            while (j < n2) {
                                tempArrStateDuringMerge[k] = R[j];
                                steps.push({ type: 'merge-place-remaining', arrayState: [...tempArrStateDuringMerge], sortedStatus: [...sortedStatus], low: l, mid: m, high: r, sourceIndex: m + 1 + j, targetIndex: k, value: R[j], fromLeft: false, message: `Placing remaining ${R[j]} from right into index ${k}` });
                                j++; k++;
                            }
                             // Update the main array and sorted status after the merge is fully visualized
                             arr = [...tempArrStateDuringMerge];
                             if (l === 0 && r === arr.length - 1) { // Mark as sorted if it's the final merge
                                 for(let idx = l; idx <= r; idx++) sortedStatus[idx] = true;
                             }
                             steps.push({ type: 'merge-done', arrayState: [...arr], sortedStatus: [...sortedStatus], low: l, high: r, message: `Merge complete for range [${l}..${r}]` });
                        }

                        function mergeSortRecursive(l, r) {
                            if (l >= r) {
                                steps.push({ type: 'base-case', arrayState: [...arr], sortedStatus: [...sortedStatus], low: l, high: r, message: `Base case reached for range [${l}..${r}].` });
                                return;
                            }
                            const m = l + Math.floor((r - l) / 2);
                            steps.push({ type: 'recursive-call', arrayState: [...arr], sortedStatus: [...sortedStatus], low: l, high: m, message: `Recursive call for left subarray [${l}..${m}]` });
                            mergeSortRecursive(l, m);
                            steps.push({ type: 'recursive-call', arrayState: [...arr], sortedStatus: [...sortedStatus], low: m + 1, high: r, message: `Recursive call for right subarray [${m+1}..${r}]` });
                            mergeSortRecursive(m + 1, r);
                            merge(l, m, r);
                        }

                        steps.push({ type: 'start', arrayState: [...arr], sortedStatus: [...sortedStatus], message: 'Starting Merge Sort' });
                        mergeSortRecursive(0, arr.length - 1);
                        steps.push({ type: 'finish', arrayState: [...arr], sortedStatus: [...sortedStatus], message: 'Array is sorted!' });

                        return { steps, elements };
                    },
                    renderStep: (step, elements) => {
                        if (!step || !elements || elements.length === 0) return;
                        const maxValue = Math.max(...step.arrayState, 1);

                        elements.forEach((bar, index) => {
                            // Reset common classes first
                            bar.className = 'vis-bar'; // Reset all specific classes
                            bar.style.opacity = '1';
                            bar.style.transform = 'translateY(0)';
                            bar.style.borderColor = 'transparent';

                            // Apply final sorted style if marked
                            if (step.sortedStatus && step.sortedStatus[index]) {
                                bar.classList.add('sorted-final');
                            }

                            // Update height and title ALWAYS
                            bar.style.height = `${(step.arrayState[index] / maxValue) * 95}%`;
                            bar.title = `Value: ${step.arrayState[index]}`;

                            if (step.low !== undefined && step.high !== undefined && step.type !== 'finish' && !bar.classList.contains('sorted-final')) {
                                if (index < step.low || index > step.high) {
                                     bar.classList.add('outside-merge-range');
                                     bar.style.opacity = '0.4';
                                } else {
                                    bar.classList.add('merge-range');
                                }
                            }
                        });

                        switch (step.type) {
                            case 'merge-compare':
                                // Highlight the original positions of the elements being compared
                                if (elements[step.leftIndex]) elements[step.leftIndex].classList.add('comparing');
                                if (elements[step.rightIndex]) elements[step.rightIndex].classList.add('comparing');
                                break;
                            case 'merge-place':
                            case 'merge-place-remaining':
                                // Highlight the target position where the element is being placed
                                if (elements[step.targetIndex]) {
                                    elements[step.targetIndex].classList.add('placing-merge');
                                    // Height/title already updated in the main loop
                                }
                                break;
                             case 'merge-done':
                                // Mark the merged range as sorted if it's the final merge
                                if (step.low === 0 && step.high === elements.length - 1) {
                                    elements.forEach(bar => bar.classList.add('sorted-final'));
                                }
                                break;
                            case 'finish':
                                elements.forEach(bar => { bar.className = 'vis-bar sorted-final'; bar.style.opacity = '1'; }); // Set final state
                                break;
                        }
                        statusMessage.textContent = step.message || '';
                    }
                },
                 // ================== HEAP SORT ==================
                'heap-sort': {
                    name: 'Heap Sort',
                    code: `<span class="code-keyword">function</span> <span class="code-function">heapSort</span>(arr) {
    <span class="code-keyword">let</span> n = arr.length;

    <span class="code-comment">// Build max heap (rearrange array)</span>
    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = Math.<span class="code-function">floor</span>(n / <span class="code-number">2</span>) - <span class="code-number">1</span>; i >= <span class="code-number">0</span>; i--) {
        <span class="code-function">heapify</span>(arr, n, i); <span class="code-comment">// Visualize heapify call</span>
    }
    <span class="code-comment">// Visualize heap built</span>

    <span class="code-comment">// One by one extract an element from heap</span>
    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = n - <span class="code-number">1</span>; i > <span class="code-number">0</span>; i--) {
        <span class="code-comment">// Move current root to end</span>
        <span class="code-comment">// Visualize swap root and end</span>
        [arr[<span class="code-number">0</span>], arr[i]] = [arr[i], arr[<span class="code-number">0</span>]];
        <span class="code-comment">// Visualize element i is now sorted</span>

        <span class="code-comment">// call max heapify on the reduced heap</span>
        <span class="code-function">heapify</span>(arr, i, <span class="code-number">0</span>); <span class="code-comment">// Visualize heapify call on reduced heap</span>
    }
    <span class="code-comment">// Visualize array sorted</span>
    <span class="code-keyword">return</span> arr;
}

<span class="code-comment">// To heapify a subtree rooted with node i which is an index in arr[]</span>
<span class="code-comment">// n is size of heap</span>
<span class="code-keyword">function</span> <span class="code-function">heapify</span>(arr, n, i) {
    <span class="code-keyword">let</span> largest = i; <span class="code-comment">// Initialize largest as root</span>
    <span class="code-keyword">let</span> l = <span class="code-number">2</span> * i + <span class="code-number">1</span>; <span class="code-comment">// left = 2*i + 1</span>
    <span class="code-keyword">let</span> r = <span class="code-number">2</span> * i + <span class="code-number">2</span>; <span class="code-comment">// right = 2*i + 2</span>
    <span class="code-comment">// Visualize comparing root, left, right</span>

    <span class="code-comment">// If left child is larger than root</span>
    <span class="code-keyword">if</span> (l < n && arr[l] > arr[largest]) {
        largest = l;
    }

    <span class="code-comment">// If right child is larger than largest so far</span>
    <span class="code-keyword">if</span> (r < n && arr[r] > arr[largest]) {
        largest = r;
    }
    <span class="code-comment">// Visualize largest identified</span>

    <span class="code-comment">// If largest is not root</span>
    <span class="code-keyword">if</span> (largest !== i) {
        <span class="code-comment">// Visualize swap i and largest</span>
        [arr[i], arr[largest]] = [arr[largest], arr[i]];

        <span class="code-comment">// Recursively heapify the affected sub-tree</span>
        <span class="code-function">heapify</span>(arr, n, largest); <span class="code-comment">// Visualize recursive heapify call</span>
    }
    <span class="code-comment">// Visualize heapify for node i complete</span>
}`,
                    pseudocode: `HeapSort(A):
  n = length(A)

  // Build max heap
  BuildMaxHeap(A, n)
  // Visualize heap built

  // Extract elements from heap one by one
  for i = n - 1 down to 1:
    // Move root (max element) to end A[i]
    swap(A[0], A[i])
    // Visualize swap and mark A[i] as sorted

    // Heapify the reduced heap (size i) starting from root (0)
    Heapify(A, i, 0)
    // Visualize heapify call

BuildMaxHeap(A, n):
  // Start from the last non-leaf node
  for i = floor(n / 2) - 1 down to 0:
    Heapify(A, n, i)
    // Visualize heapify call

Heapify(A, heapSize, i):
  largest = i       // Initialize largest as root
  left = 2*i + 1
  right = 2*i + 2
  // Visualize comparing root i, left, right

  // If left child exists and is larger than root
  if left < heapSize and A[left] > A[largest]:
    largest = left

  // If right child exists and is larger than largest so far
  if right < heapSize and A[right] > A[largest]:
    largest = right
  // Visualize largest identified

  // If largest is not the root
  if largest != i:
    // Swap A[i] and A[largest]
    swap(A[i], A[largest])
    // Visualize swap

    // Recursively heapify the affected sub-tree
    Heapify(A, heapSize, largest)
    // Visualize recursive heapify call
  // Visualize heapify for node i complete`,
                    setup: (data) => {
                        visualizationArea.innerHTML = ''; // Clear main area
                        extraVisualizationArea.innerHTML = ''; // Clear extra area
                        if (!data || data.length === 0) {
                            visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">Cannot visualize empty array.</p>`;
                            return { steps: [], elements: [] };
                        }
                        const maxValue = Math.max(...data, 1);
                        const elements = data.map((value) => {
                            const bar = document.createElement('div');
                            bar.classList.add('vis-bar');
                            bar.style.height = `${(value / maxValue) * 95}%`;
                            bar.setAttribute('data-value', value);
                            bar.title = `Value: ${value}`;
                            visualizationArea.appendChild(bar);
                            return bar;
                        });

                        let steps = [];
                        let arr = [...data];
                        const n = arr.length;
                        let sortedStatus = new Array(n).fill(false); // Track final sorted elements

                        // Helper function to generate heapify steps
                        function heapify(heapSize, i) {
                            let largest = i;
                            let l = 2 * i + 1;
                            let r = 2 * i + 2;
                            let compareIndices = [i];
                            if (l < heapSize) compareIndices.push(l);
                            if (r < heapSize) compareIndices.push(r);

                            steps.push({ type: 'heapify-compare', arrayState: [...arr], sortedStatus: [...sortedStatus], heapSize: heapSize, compareIndices: compareIndices, currentLargest: largest, message: `Heapify(${i}): Comparing node ${i} (${arr[i]}) with children.` });

                            if (l < heapSize && arr[l] > arr[largest]) {
                                largest = l;
                            }
                            if (r < heapSize && arr[r] > arr[largest]) {
                                largest = r;
                            }

                            steps.push({ type: 'heapify-largest', arrayState: [...arr], sortedStatus: [...sortedStatus], heapSize: heapSize, compareIndices: compareIndices, largest: largest, message: `Heapify(${i}): Largest is at index ${largest} (${arr[largest]})` });

                            if (largest !== i) {
                                steps.push({ type: 'heapify-swap', arrayState: [...arr], sortedStatus: [...sortedStatus], heapSize: heapSize, swapIndices: [i, largest], message: `Heapify(${i}): Swapping node ${i} (${arr[i]}) with largest ${largest} (${arr[largest]})` });
                                [arr[i], arr[largest]] = [arr[largest], arr[i]];
                                steps.push({ type: 'after-heapify-swap', arrayState: [...arr], sortedStatus: [...sortedStatus], heapSize: heapSize, swapIndices: [i, largest], message: `Heapify(${i}): Swap complete. Recursively heapify subtree at ${largest}.` });
                                heapify(heapSize, largest); // Recursive call
                            } else {
                                 steps.push({ type: 'heapify-done', arrayState: [...arr], sortedStatus: [...sortedStatus], heapSize: heapSize, nodeIndex: i, message: `Heapify(${i}): Node ${i} (${arr[i]}) is already largest. Heap property satisfied.` });
                            }
                        }

                        steps.push({ type: 'start', arrayState: [...arr], sortedStatus: [...sortedStatus], message: 'Starting Heap Sort' });
                        steps.push({ type: 'build-heap-start', arrayState: [...arr], sortedStatus: [...sortedStatus], message: 'Building Max Heap...' });

                        // Build max heap
                        for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                            steps.push({ type: 'heapify-call', arrayState: [...arr], sortedStatus: [...sortedStatus], heapSize: n, nodeIndex: i, message: `Calling Heapify on node ${i}` });
                            heapify(n, i);
                        }
                         steps.push({ type: 'build-heap-done', arrayState: [...arr], sortedStatus: [...sortedStatus], message: 'Max Heap built.' });

                        // Extract elements
                        for (let i = n - 1; i > 0; i--) {
                            steps.push({ type: 'extract-swap', arrayState: [...arr], sortedStatus: [...sortedStatus], heapSize: i + 1, swapIndices: [0, i], message: `Extract Max: Swapping root (${arr[0]}) with end of heap (${arr[i]})` });
                            [arr[0], arr[i]] = [arr[i], arr[0]];
                            sortedStatus[i] = true; // Mark extracted element as sorted
                            steps.push({ type: 'after-extract-swap', arrayState: [...arr], sortedStatus: [...sortedStatus], heapSize: i, sortedIndex: i, message: `Element ${arr[i]} moved to sorted position ${i}.` });

                            steps.push({ type: 'heapify-call', arrayState: [...arr], sortedStatus: [...sortedStatus], heapSize: i, nodeIndex: 0, message: `Heapify reduced heap (size ${i}) from root 0` });
                            heapify(i, 0); // Heapify the reduced heap
                        }
                         // Mark the first element as sorted too
                         if (n > 0) sortedStatus[0] = true;
                         steps.push({ type: 'mark-sorted', arrayState: [...arr], sortedStatus: [...sortedStatus], index: 0, message: `Element at index 0 is now sorted.` });

                        steps.push({ type: 'finish', arrayState: [...arr], sortedStatus: [...sortedStatus], message: 'Array is sorted!' });

                        return { steps, elements };
                    },
                    renderStep: (step, elements) => {
                        if (!step || !elements || elements.length === 0) return;
                        const maxValue = Math.max(...step.arrayState, 1);

                        elements.forEach((bar, index) => {
                            // Reset common classes first
                            bar.className = 'vis-bar'; // Reset all specific classes
                            bar.style.opacity = '1';
                            bar.style.transform = 'translateY(0)';
                            bar.style.borderColor = 'transparent';

                            // Apply final sorted style if marked
                            if (step.sortedStatus && step.sortedStatus[index]) {
                                bar.classList.add('sorted-final');
                            }

                            // Update height and title ALWAYS
                            bar.style.height = `${(step.arrayState[index] / maxValue) * 95}%`;
                            bar.title = `Value: ${step.arrayState[index]}`;

                            // Highlight the current heap range (dim outside)
                            if (step.heapSize !== undefined && step.type !== 'finish' && !bar.classList.contains('sorted-final')) {
                                if (index >= step.heapSize) {
                                     bar.classList.add('outside-heap-range');
                                     bar.style.opacity = '0.4';
                                } else {
                                    bar.classList.add('heap-range');
                                }
                            }
                        });

                        // Apply step-specific styling
                        switch (step.type) {
                            case 'heapify-call':
                            case 'heapify-done':
                                if (elements[step.nodeIndex] && !elements[step.nodeIndex].classList.contains('sorted-final')) elements[step.nodeIndex].classList.add('heapify-node');
                                break;
                            case 'heapify-compare':
                                step.compareIndices.forEach(idx => {
                                    if (elements[idx] && !elements[idx].classList.contains('sorted-final')) elements[idx].classList.add('heapify-node');
                                });
                                break;
                            case 'heapify-largest':
                                step.compareIndices.forEach(idx => {
                                    if (elements[idx] && !elements[idx].classList.contains('sorted-final')) elements[idx].classList.add('heapify-node');
                                });
                                if (elements[step.largest] && !elements[step.largest].classList.contains('sorted-final')) elements[step.largest].classList.add('heapify-largest');
                                break;
                            case 'heapify-swap':
                            case 'after-heapify-swap':
                                if (elements[step.swapIndices[0]] && !elements[step.swapIndices[0]].classList.contains('sorted-final')) elements[step.swapIndices[0]].classList.add('swapping');
                                if (elements[step.swapIndices[1]] && !elements[step.swapIndices[1]].classList.contains('sorted-final')) elements[step.swapIndices[1]].classList.add('swapping');
                                break;
                            case 'extract-swap':
                            case 'after-extract-swap':
                                if (elements[step.swapIndices[0]] && !elements[step.swapIndices[0]].classList.contains('sorted-final')) elements[step.swapIndices[0]].classList.add('swapping');
                                if (elements[step.swapIndices[1]] && !elements[step.swapIndices[1]].classList.contains('sorted-final')) elements[step.swapIndices[1]].classList.add('swapping');
                                break;
                             case 'mark-sorted': // Handles marking during extraction and the final element
                                // Style applied in the initial loop based on sortedStatus
                                break;
                            case 'finish':
                                elements.forEach(bar => { bar.className = 'vis-bar sorted-final'; bar.style.opacity = '1'; }); // Set final state
                                break;
                        }
                        statusMessage.textContent = step.message || '';
                    }
                },
                // ================== COUNTING SORT ==================
                'counting-sort': {
                    name: 'Counting Sort',
                    requiresPositiveInts: true, // Add flag for data generation
                    code: `<span class="code-keyword">function</span> <span class="code-function">countingSort</span>(arr) {
  <span class="code-keyword">if</span> (arr.length === <span class="code-number">0</span>) <span class="code-keyword">return</span> arr;

  <span class="code-comment">// 1. Find the maximum element to determine range</span>
  <span class="code-keyword">let</span> max = arr[<span class="code-number">0</span>];
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">1</span>; i < arr.length; i++) {
    <span class="code-keyword">if</span> (arr[i] > max) {
      max = arr[i];
    }
  }
  <span class="code-comment">// Visualize max found</span>

  <span class="code-comment">// 2. Initialize count array with zeros</span>
  <span class="code-keyword">const</span> count = <span class="code-keyword">new</span> <span class="code-function">Array</span>(max + <span class="code-number">1</span>).<span class="code-function">fill</span>(<span class="code-number">0</span>);
  <span class="code-comment">// Visualize count array initialized</span>

  <span class="code-comment">// 3. Store count of each element</span>
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < arr.length; i++) {
    count[arr[i]]++;
    <span class="code-comment">// Visualize incrementing count[arr[i]]</span>
  }

  <span class="code-comment">// 4. Store cumulative count (modify count array)</span>
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">1</span>; i <= max; i++) {
    count[i] += count[i - <span class="code-number">1</span>];
    <span class="code-comment">// Visualize updating count[i] with cumulative sum</span>
  }

  <span class="code-comment">// 5. Build the output array (iterate backwards for stability)</span>
  <span class="code-keyword">const</span> output = <span class="code-keyword">new</span> <span class="code-function">Array</span>(arr.length);
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = arr.length - <span class="code-number">1</span>; i >= <span class="code-number">0</span>; i--) {
    <span class="code-keyword">const</span> value = arr[i];
    <span class="code-keyword">const</span> position = count[value] - <span class="code-number">1</span>;
    output[position] = value;
    count[value]--; <span class="code-comment">// Decrement count for next same element</span>
    <span class="code-comment">// Visualize placing value in output[position] and decrementing count[value]</span>
  }

  <span class="code-comment">// 6. Copy the sorted output array back to the original array</span>
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < arr.length; i++) {
    arr[i] = output[i];
    <span class="code-comment">// Visualize copying back to original array</span>
  }

  <span class="code-keyword">return</span> arr;
}`,
                    pseudocode: `CountingSort(A):
  if length(A) == 0: return A

  // 1. Find maximum element k
  k = max(A)
  // Visualize max found

  // 2. Initialize count array C of size k+1 with zeros
  C = array of size (k + 1) initialized to 0
  // Visualize count array C initialized

  // 3. Count occurrences of each element in A
  for i = 0 to length(A) - 1:
    C[A[i]] = C[A[i]] + 1
    // Visualize incrementing C[A[i]]

  // 4. Calculate cumulative counts (positions)
  for i = 1 to k:
    C[i] = C[i] + C[i - 1]
    // Visualize updating C[i]

  // 5. Build the output array B (iterate backwards for stability)
  B = array of size length(A)
  for i = length(A) - 1 down to 0:
    value = A[i]
    position = C[value] - 1
    B[position] = value
    C[value] = C[value] - 1 // Decrement count
    // Visualize placing value in B[position] and decrementing C[value]

  // 6. Copy sorted array B back to A
  for i = 0 to length(A) - 1:
    A[i] = B[i]
    // Visualize copying back to A

  return A`,
                    setup: (data) => {
                        visualizationArea.innerHTML = ''; // Clear main area
                        extraVisualizationArea.innerHTML = ''; // Clear extra area

                        if (!data || data.length === 0) {
                            visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">Cannot visualize empty array.</p>`;
                            return { steps: [], elements: [], countElements: [], outputElements: [] };
                        }
                        if (data.some(val => val < 0 || !Number.isInteger(val))) {
                             visualizationArea.innerHTML = `<p class="text-red-500 dark:text-red-400 self-center">Counting Sort requires non-negative integers.</p>`;
                             return { steps: [], elements: [], countElements: [], outputElements: [] };
                        }

                        const arr = [...data];
                        const n = arr.length;
                        const dataMaxValue = Math.max(...arr, 0); // Find max value in data
                        const visMaxValue = Math.max(...arr, 1); // For scaling bars

                        // Create main visualization bars
                        const elements = arr.map((value) => {
                            const bar = document.createElement('div');
                            bar.classList.add('vis-bar');
                            bar.style.height = `${(value / visMaxValue) * 95}%`; // Scale based on max value
                            bar.setAttribute('data-value', value);
                            bar.title = `Value: ${value}`;
                            visualizationArea.appendChild(bar);
                            return bar;
                        });

                        // Create Count Array Visualization Area
                        const countVisContainer = document.createElement('div');
                        countVisContainer.id = 'count-array-vis';
                        countVisContainer.className = 'count-array-vis';
                        countVisContainer.setAttribute('data-label', 'Count Array');
                        extraVisualizationArea.appendChild(countVisContainer);
                        const countElements = [];
                        for (let i = 0; i <= dataMaxValue; i++) {
                            const cell = document.createElement('div');
                            cell.className = 'count-cell';
                            cell.textContent = '0';
                            cell.setAttribute('data-index', i);
                            cell.title = `Index: ${i}`;
                            countVisContainer.appendChild(cell);
                            countElements.push(cell);
                        }

                        // Create Output Array Visualization Area
                        const outputVisContainer = document.createElement('div');
                        outputVisContainer.id = 'output-array-vis';
                        outputVisContainer.className = 'output-array-vis';
                        outputVisContainer.setAttribute('data-label', 'Output Array');
                        extraVisualizationArea.appendChild(outputVisContainer);
                        const outputElements = [];
                        for (let i = 0; i < n; i++) {
                            const cell = document.createElement('div');
                            cell.className = 'output-cell empty'; // Start as empty
                            cell.textContent = '?';
                            cell.setAttribute('data-index', i);
                             cell.title = `Index: ${i}`;
                            outputVisContainer.appendChild(cell);
                            outputElements.push(cell);
                        }


                        let steps = [];
                        let currentArr = [...arr]; // Use a copy for generating steps
                        let count = new Array(dataMaxValue + 1).fill(0);
                        let output = new Array(n);

                        steps.push({ type: 'start', arrayState: [...currentArr], countState: [...count], outputState: [...output], message: `Starting Counting Sort. Max value: ${dataMaxValue}` });

                        // 1. Count occurrences
                        steps.push({ type: 'phase-count', arrayState: [...currentArr], countState: [...count], outputState: [...output], message: `Phase 1: Counting occurrences` });
                        for (let i = 0; i < n; i++) {
                            steps.push({ type: 'read-input-count', arrayState: [...currentArr], countState: [...count], outputState: [...output], readIndex: i, value: currentArr[i], message: `Reading input[${i}] = ${currentArr[i]}` });
                            count[currentArr[i]]++;
                            steps.push({ type: 'increment-count', arrayState: [...currentArr], countState: [...count], outputState: [...output], countIndex: currentArr[i], readIndex: i, message: `Incrementing count[${currentArr[i]}] to ${count[currentArr[i]]}` });
                        }

                        // 2. Calculate cumulative counts
                        steps.push({ type: 'phase-cumulative', arrayState: [...currentArr], countState: [...count], outputState: [...output], message: `Phase 2: Calculating cumulative counts` });
                        for (let i = 1; i <= dataMaxValue; i++) {
                            steps.push({ type: 'read-cumulative', arrayState: [...currentArr], countState: [...count], outputState: [...output], currentIndex: i, prevIndex: i-1, message: `Reading count[${i-1}] (${count[i-1]}) and count[${i}] (${count[i]})` });
                            count[i] += count[i - 1];
                            steps.push({ type: 'write-cumulative', arrayState: [...currentArr], countState: [...count], outputState: [...output], writeIndex: i, message: `Updating count[${i}] to cumulative sum ${count[i]}` });
                        }

                        // 3. Build output array
                        steps.push({ type: 'phase-output', arrayState: [...currentArr], countState: [...count], outputState: [...output], message: `Phase 3: Building output array (stable)` });
                        for (let i = n - 1; i >= 0; i--) {
                            const value = currentArr[i];
                            steps.push({ type: 'read-input-output', arrayState: [...currentArr], countState: [...count], outputState: [...output], readIndex: i, value: value, message: `Reading input[${i}] = ${value}` });
                            steps.push({ type: 'read-count-pos', arrayState: [...currentArr], countState: [...count], outputState: [...output], readIndex: i, value: value, countIndex: value, message: `Reading position from count[${value}] = ${count[value]}` });
                            const position = count[value] - 1;
                            output[position] = value;
                            steps.push({ type: 'write-output', arrayState: [...currentArr], countState: [...count], outputState: [...output], readIndex: i, value: value, writeIndex: position, message: `Placing ${value} into output[${position}]` });
                            count[value]--;
                            steps.push({ type: 'decrement-count-output', arrayState: [...currentArr], countState: [...count], outputState: [...output], readIndex: i, value: value, countIndex: value, message: `Decrementing count[${value}] to ${count[value]}` });
                        }

                         // 4. Copy back to original array (optional visualization step)
                        steps.push({ type: 'phase-copy', arrayState: [...currentArr], countState: [...count], outputState: [...output], message: `Phase 4: Copying sorted output back to input` });
                        for (let i = 0; i < n; i++) {
                            currentArr[i] = output[i];
                            steps.push({ type: 'copy-back', arrayState: [...currentArr], countState: [...count], outputState: [...output], index: i, message: `Copying output[${i}] (${output[i]}) to input[${i}]` });
                        }

                        steps.push({ type: 'finish', arrayState: [...currentArr], countState: [...count], outputState: [...output], message: 'Array is sorted!' });

                        return { steps, elements, countElements, outputElements };
                    },
                    renderStep: (step, elements, animationState) => {
                        if (!step || !elements || !animationState.countElements || !animationState.outputElements) return;

                        const visMaxValue = Math.max(...step.arrayState, 1); // Max for scaling bars
                        const { countElements, outputElements } = animationState;

                        // --- Reset Highlights ---
                        elements.forEach(bar => bar.className = 'vis-bar'); // Reset main bars
                        countElements.forEach(cell => cell.className = 'count-cell'); // Reset count cells
                        outputElements.forEach(cell => cell.className = `output-cell ${cell.textContent === '?' ? 'empty' : ''}`); // Reset output cells, keep empty state

                        // --- Update Array States ---
                        // Update main bars based on arrayState
                        elements.forEach((bar, index) => {
                            const value = step.arrayState[index];
                            bar.style.height = `${(value / visMaxValue) * 95}%`;
                            bar.title = `Value: ${value}`;
                            bar.setAttribute('data-value', value);
                            if (step.type === 'finish' || (step.type === 'copy-back' && index <= step.index)) {
                                bar.classList.add('sorted-final');
                            }
                        });

                        // Update count array visualization
                        countElements.forEach((cell, index) => {
                            if (step.countState && index < step.countState.length) {
                                cell.textContent = step.countState[index];
                            } else if (index >= step.countState?.length) {
                                // Hide cells beyond the max value if needed, though setup should handle this
                                cell.style.display = 'none';
                            }
                        });

                        // Update output array visualization
                        outputElements.forEach((cell, index) => {
                            if (step.outputState && index < step.outputState.length && step.outputState[index] !== undefined) {
                                cell.textContent = step.outputState[index];
                                cell.classList.remove('empty');
                            } else {
                                cell.textContent = '?';
                                cell.classList.add('empty');
                            }
                        });


                        // --- Apply Step-Specific Highlights ---
                        switch (step.type) {
                            case 'read-input-count':
                                if (elements[step.readIndex]) elements[step.readIndex].classList.add('reading');
                                if (countElements[step.value]) countElements[step.value].classList.add('highlight-read');
                                break;
                            case 'increment-count':
                                if (elements[step.readIndex]) elements[step.readIndex].classList.add('reading'); // Keep input highlighted
                                if (countElements[step.countIndex]) countElements[step.countIndex].classList.add('highlight-write');
                                break;
                            case 'read-cumulative':
                                if (countElements[step.currentIndex]) countElements[step.currentIndex].classList.add('highlight-read');
                                if (countElements[step.prevIndex]) countElements[step.prevIndex].classList.add('highlight-read');
                                break;
                            case 'write-cumulative':
                                if (countElements[step.writeIndex]) countElements[step.writeIndex].classList.add('highlight-write');
                                break;
                            case 'read-input-output':
                                if (elements[step.readIndex]) elements[step.readIndex].classList.add('reading');
                                break;
                            case 'read-count-pos':
                                if (elements[step.readIndex]) elements[step.readIndex].classList.add('reading'); // Keep input highlighted
                                if (countElements[step.countIndex]) countElements[step.countIndex].classList.add('highlight-read');
                                break;
                            case 'write-output':
                                if (elements[step.readIndex]) elements[step.readIndex].classList.add('reading'); // Keep input highlighted
                                if (countElements[step.value]) countElements[step.value].classList.add('highlight-read'); // Show count being read
                                if (outputElements[step.writeIndex]) outputElements[step.writeIndex].classList.add('highlight-write');
                                break;
                            case 'decrement-count-output':
                                if (elements[step.readIndex]) elements[step.readIndex].classList.add('reading'); // Keep input highlighted
                                if (outputElements[step.writeIndex]) outputElements[step.writeIndex].classList.add('highlight-write'); // Keep output highlighted
                                if (countElements[step.countIndex]) countElements[step.countIndex].classList.add('highlight-write'); // Show count being decremented
                                break;
                            case 'copy-back':
                                if (outputElements[step.index]) outputElements[step.index].classList.add('highlight-read');
                                if (elements[step.index]) elements[step.index].classList.add('writing');
                                break;
                            case 'finish':
                                elements.forEach(bar => bar.classList.add('sorted-final'));
                                break;
                        }

                        statusMessage.textContent = step.message || '';
                    }
                },
                 'tree-traversals': { name: 'Tree Traversals', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'bst': { name: 'Binary Search Tree', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'avl': { name: 'AVL Tree Rotations', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'heap-ops': { name: 'Heap Operations', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'tree-bfs-dfs': { name: 'BFS & DFS (Trees)', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'graph-bfs': { name: 'BFS (Graphs)', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'graph-dfs': { name: 'DFS (Graphs)', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'dijkstra': { name: 'Dijkstra’s Algorithm', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'bellman-ford': { name: 'Bellman-Ford', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'floyd-warshall': { name: 'Floyd-Warshall', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'kruskal': { name: 'Kruskal’s MST', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'prim': { name: 'Prim’s MST', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'topo-sort': { name: 'Topological Sorting', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'fibonacci': { name: 'Fibonacci', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'lcs': { name: 'Longest Common Subsequence', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'knapsack': { name: '0/1 Knapsack', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'coin-change': { name: 'Coin Change', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'mcm': { name: 'Matrix Chain Multiplication', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'n-queens': { name: 'N-Queens', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'sudoku': { name: 'Sudoku Solver', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'rat-maze': { name: 'Rat in a Maze', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'word-search': { name: 'Word Search', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'union-find': { name: 'Union-Find', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'kmp': { name: 'KMP Algorithm', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'rabin-karp': { name: 'Rabin-Karp', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'sliding-window': { name: 'Sliding Window', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
                 'two-pointers': { name: 'Two Pointers', code: '// TODO', pseudocode: '// TODO', setup: defaultSetup, renderStep: defaultRender },
            };

            // --- Default/Placeholder Functions ---
            function defaultSetup(data) {
                 const algoName = this && this.name ? this.name : 'Algorithm';
                 visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">${algoName} visualization not implemented yet.</p>`;
                 extraVisualizationArea.innerHTML = ''; // Clear extra area for defaults too
                 return { steps: [], elements: [] };
            }
            function defaultRender(step, elements, animationState) {
                statusMessage.textContent = 'Visualization logic not implemented.';
            }

             // Add default functions to algorithms that don't have them yet
            for (const key in algorithms) {
                if (!algorithms[key].setup) algorithms[key].setup = defaultSetup.bind(algorithms[key]);
                if (!algorithms[key].renderStep) algorithms[key].renderStep = defaultRender;
            }

            // --- Helper Functions ---
            function calculateDelay(sliderValue) {
                const minDelay = 50; const maxDelay = 1500;
                return maxDelay - (sliderValue - 1) * (maxDelay - minDelay) / (speedSlider.max - 1);
            }

            function generateSampleData(algoKey) {
                const size = 20;
                let minVal = 10;
                let maxVal = 100;
                let onlyPositiveInts = false;

                // Check for specific requirements
                if (algorithms[algoKey]) {
                    if (algorithms[algoKey].requiresPositiveInts) {
                        onlyPositiveInts = true;
                        minVal = 0; // Counting sort needs non-negative
                        maxVal = 50; // Keep range reasonable for counting sort vis
                    }
                }

                let data = Array.from({ length: size }, () => {
                    let val = Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal;
                    return onlyPositiveInts ? Math.max(0, val) : val; // Ensure positive if needed
                });


                // Check if the selected algorithm requires sorted data (after potential adjustments)
                if (algorithms[algoKey] && algorithms[algoKey].requiresSortedData) {
                    data.sort((a, b) => a - b);
                }
                return data;
            }

            // --- Core Application Logic ---
            function selectAlgorithm(algoKey) {
                if (!algorithms[algoKey]) {
                    console.error(`Algorithm "${algoKey}" not found.`);
                    currentAlgoTitle.textContent = 'Algorithm Not Found';
                    codeBlock.textContent = '// Algorithm definition missing';
                    pseudoBlock.textContent = '// Algorithm definition missing';
                    resetVisualizationState();
                    visualizationArea.innerHTML = `<p class="text-red-500 dark:text-red-400 self-center">Error: Algorithm '${algoKey}' not defined.</p>`;
                    extraVisualizationArea.innerHTML = ''; // Clear extra area
                    return;
                }
                pauseAnimation();
                currentAlgorithmKey = algoKey;
                currentAlgorithm = algorithms[algoKey];
                currentData = generateSampleData(currentAlgorithmKey);

                console.log(`Selected: ${currentAlgorithm.name}`);
                currentAlgoTitle.textContent = currentAlgorithm.name;
                codeBlock.innerHTML = currentAlgorithm.code || '// Code not available';
                pseudoBlock.textContent = currentAlgorithm.pseudocode || '// Pseudocode not available';
                setupVisualization();
            }

            function setupVisualization() {
                if (!currentAlgorithm || !currentData) return;
                // Reset parts of animation state but keep speed
                 animationState = {
                    ...animationState, // Keep speed, isPlaying etc.
                    steps: [],
                    elements: [],
                    countElements: [],
                    outputElements: [],
                    currentStep: -1,
                    targetValue: null,
                 };

                const setupResult = currentAlgorithm.setup(currentData);
                animationState.steps = setupResult.steps || [];
                animationState.elements = setupResult.elements || [];
                // Store references to count/output elements if created by setup
                animationState.countElements = setupResult.countElements || [];
                animationState.outputElements = setupResult.outputElements || [];
                animationState.targetValue = setupResult.target; // For search
                animationState.currentStep = 0;


                if (animationState.steps.length > 0) {
                    // Pass the full animationState to renderStep
                    currentAlgorithm.renderStep(animationState.steps[0], animationState.elements, animationState);
                } else if (visualizationArea.innerHTML.includes('not implemented yet') || visualizationArea.innerHTML.includes('requires non-negative integers')) {
                     // Don't reset status message if setup showed an error/message
                } else {
                    visualizationArea.innerHTML = `<p class="text-gray-500 dark:text-gray-400 self-center">No visualization steps generated.</p>`;
                    extraVisualizationArea.innerHTML = ''; // Clear extra area
                    statusMessage.textContent = 'Ready';
                }
                updateButtonStates();
            }

            function resetVisualizationState() {
                pauseAnimation();
                currentAlgorithmKey = null; currentAlgorithm = null; currentData = [];
                animationState = {
                    steps: [], elements: [], countElements: [], outputElements: [], currentStep: -1, isPlaying: false,
                    timerId: null, speed: calculateDelay(speedSlider.value), targetValue: null,
                };
                visualizationArea.innerHTML = '<p class="text-gray-500 dark:text-gray-400 self-center">Select an Algorithm</p>';
                extraVisualizationArea.innerHTML = ''; // Clear extra area
                currentAlgoTitle.textContent = 'Select an Algorithm';
                codeBlock.textContent = '// Select an algorithm to view the code';
                pseudoBlock.textContent = '// Select an algorithm to view the pseudocode';
                statusMessage.textContent = '';
                updateButtonStates();
                document.querySelectorAll('#algo-nav a.active').forEach(a => a.classList.remove('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300', 'font-semibold', 'active'));
            }

            function switchTab(tabName) {
                tabButtons.forEach(button => {
                    const isActive = button.dataset.tab === tabName;
                    button.classList.toggle('active', isActive); button.classList.toggle('border-blue-500', isActive);
                    button.classList.toggle('text-blue-600', isActive); button.classList.toggle('dark:text-blue-400', isActive);
                    button.classList.toggle('border-transparent', !isActive); button.classList.toggle('text-gray-500', !isActive);
                    button.classList.toggle('dark:text-gray-400', !isActive); button.classList.toggle('hover:text-gray-700', !isActive);
                    button.classList.toggle('dark:hover:text-gray-300', !isActive); button.classList.toggle('hover:border-gray-300', !isActive);
                    button.classList.toggle('dark:hover:border-gray-600', !isActive);
                });
                codeContent.style.display = tabName === 'code' ? 'block' : 'none';
                pseudoContent.style.display = tabName === 'pseudo' ? 'block' : 'none';
            }

            function updateSpeed() {
                animationState.speed = calculateDelay(speedSlider.value);
                if (animationState.isPlaying) { pauseAnimation(); playAnimation(); }
            }

            function togglePlayPause() {
                if (animationState.isPlaying) { pauseAnimation(); } else { playAnimation(); }
            }

            function playAnimation() {
                if (!currentAlgorithm || animationState.isPlaying || animationState.currentStep >= animationState.steps.length - 1) {
                    if (animationState.currentStep >= animationState.steps.length - 1) { pauseAnimation(); } return;
                }
                animationState.isPlaying = true;
                playPauseBtn.textContent = 'Pause';
                playPauseBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                playPauseBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                updateButtonStates();
                function step() {
                    if (!animationState.isPlaying) return;
                    if (animationState.currentStep < animationState.steps.length - 1) {
                        animationState.currentStep++;
                        // Pass full animationState to renderStep
                        currentAlgorithm.renderStep(animationState.steps[animationState.currentStep], animationState.elements, animationState);
                        updateButtonStates();
                        animationState.timerId = setTimeout(step, animationState.speed);
                    } else { pauseAnimation(); }
                }
                animationState.timerId = setTimeout(step, animationState.speed);
            }

            function pauseAnimation() {
                animationState.isPlaying = false;
                playPauseBtn.textContent = 'Play';
                playPauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                playPauseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                clearTimeout(animationState.timerId);
                animationState.timerId = null;
                updateButtonStates();
            }

            function stepForward() {
                if (!currentAlgorithm || animationState.isPlaying || animationState.currentStep >= animationState.steps.length - 1) return;
                pauseAnimation();
                animationState.currentStep++;
                 // Pass full animationState to renderStep
                currentAlgorithm.renderStep(animationState.steps[animationState.currentStep], animationState.elements, animationState);
                updateButtonStates();
            }

            function stepBack() {
                if (!currentAlgorithm || animationState.isPlaying || animationState.currentStep <= 0) return;
                pauseAnimation();
                animationState.currentStep--;
                 // Pass full animationState to renderStep
                currentAlgorithm.renderStep(animationState.steps[animationState.currentStep], animationState.elements, animationState);
                updateButtonStates();
            }

            function resetToStart() {
                if (!currentAlgorithm || animationState.steps.length === 0) return;
                pauseAnimation();
                animationState.currentStep = 0;
                 // Pass full animationState to renderStep
                currentAlgorithm.renderStep(animationState.steps[0], animationState.elements, animationState);
                updateButtonStates();
            }

            function handleGenerateData() {
                 if (!currentAlgorithmKey) { statusMessage.textContent = "Please select an algorithm first."; return; }
                 currentData = generateSampleData(currentAlgorithmKey); // Regenerate, respecting algo requirements
                 setupVisualization();
            }

            function updateButtonStates() {
                const stepsAvailable = animationState.steps.length > 0;
                const isAtStart = animationState.currentStep <= 0;
                const isAtEnd = animationState.currentStep >= animationState.steps.length - 1;
                playPauseBtn.disabled = !stepsAvailable || isAtEnd || !currentAlgorithm;
                stepForwardBtn.disabled = !stepsAvailable || isAtEnd || animationState.isPlaying || !currentAlgorithm;
                stepBackBtn.disabled = !stepsAvailable || isAtStart || animationState.isPlaying || !currentAlgorithm;
                resetBtn.disabled = !stepsAvailable || !currentAlgorithm;
                generateDataBtn.disabled = !currentAlgorithmKey;
                if (!animationState.isPlaying) {
                    playPauseBtn.textContent = 'Play';
                    playPauseBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                    playPauseBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                }
                if (isAtEnd && stepsAvailable) { playPauseBtn.textContent = 'Done'; }
            }

            // --- Event Listeners ---
            algoNav.addEventListener('click', (e) => {
                if (e.target.tagName === 'A' && e.target.dataset.algo) {
                    e.preventDefault(); const algoKey = e.target.dataset.algo;
                    document.querySelectorAll('#algo-nav a.active').forEach(a => a.classList.remove('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300', 'font-semibold', 'active'));
                    e.target.classList.add('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300', 'font-semibold', 'active');
                    selectAlgorithm(algoKey);
                }
            });
            darkModeToggle.addEventListener('change', () => {
                if (darkModeToggle.checked) { document.documentElement.classList.add('dark'); localStorage.setItem('darkMode', 'enabled'); }
                else { document.documentElement.classList.remove('dark'); localStorage.setItem('darkMode', 'disabled'); }
            });
            if (localStorage.getItem('darkMode') === 'enabled') { darkModeToggle.checked = true; document.documentElement.classList.add('dark'); }
            else { document.documentElement.classList.remove('dark'); }
            tabButtons.forEach(button => {
                button.addEventListener('click', () => switchTab(button.dataset.tab));
                button.classList.add('py-2', 'px-3', 'text-sm', 'font-medium', 'border-b-2', 'focus:outline-none', 'transition-colors', 'duration-150');
            });
            switchTab('code');
            playPauseBtn.addEventListener('click', togglePlayPause);
            stepForwardBtn.addEventListener('click', stepForward);
            stepBackBtn.addEventListener('click', stepBack);
            resetBtn.addEventListener('click', resetToStart);
            generateDataBtn.addEventListener('click', handleGenerateData);
            speedSlider.addEventListener('input', updateSpeed);

            // --- Initial Setup ---
            resetVisualizationState();

        }); // End DOMContentLoaded
    </script>
</body>
</html>
